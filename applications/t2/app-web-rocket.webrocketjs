var _MSG_INTRODUCTION    = "MSG_Action_Introduction";
var _MSG_RAYCAST = "MSG_raycast";

console.log("haha");
var WebRocketApplication = IApplication.$extend(
{
    __init__ : function()
    {
        this.$super("t2");
		var self = this;
        this.initUi();

		var rayCastEnt;
		this.rayCastEnt = rayCastEnt;
		window.AudioContext	= window.AudioContext || window.webkitAudioContext;
		var context	= new AudioContext();
		console.log(context);
		var listOfMeshObject = [];
		listOfMeshObject = this.getListOfMeshObj();
		this.listOfMeshObject = listOfMeshObject;
		
		console.log("client connected");
		console.log(this.entity);
		var foothold = Tundra.scene.entityByName("soapbox_footbold");
		this.foothold = foothold;
        // Listen for client/server sent entity actions
        this.entity.onEntityAction(this, this.onEntityAction);
		this.foothold.onEntityAction(this, this.object);

        // Introduce client app to the server
        this.entity.exec(EntityAction.Server, _MSG_INTRODUCTION);
		/* Json object loader*/
		var loader = new THREE.JSONLoader();
		
		var jsonData = Tundra.asset.requestAsset("hotspots.json");
		entFoothold = jsonData.onCompleted(this, this.haejongAsset)
		
		/* dynamic objects and movement that require to render everytime*/
		var onRenderFctsWithoutParam = []; 
		/* get camera entity*/
		var cameraEnt = Tundra.client.cameraApplications[0].application.cameraEntity;		
		
		console.log(Tundra.client);
		console.log(Tundra.scene);

		/////////////////// webRTC //////////////////////////////	
		/*create a video element in document */
		var video = document.createElement('video');
		this.video = video;
		video.width = 320;
		video.height = 240;
		video.autoplay = true;
		video.loop = true;
		
		/* get video stream */
		if( navigator.webkitGetUserMedia ){
			navigator.webkitGetUserMedia({video:true}, function(stream){
				video.src	= URL.createObjectURL(stream);
			}, function(error){
				alert('you have got no WebRTC webcam');
			});		
		}else if(navigator.mozGetUserMedia){
			navigator.mozGetUserMedia({video:true}, function(stream){
				video.src	= URL.createObjectURL(stream);
			}, function(error){
				alert('you have got no WebRTC webcam');
			});				
		}else	
		console.assert(false);
	
		console.log(this);
		//---------------------------------------//
		
		/*create video texture */
		var videotexture = new THREE.Texture(video);
		this.videotexture = videotexture;
		
		onRenderFctsWithoutParam.push(function(){
			self.videoTextureUpdate();
		});
		onRenderFctsWithoutParam.push(function(){
			self.rayCast();
		});		
		var bufferGeoTest = THREE.BufferGeometry();
		console.log(Tundra.renderer.scene, bufferGeoTest);
	
		///////////////////////////////////////////////////////
		

		var sub = Tundra.events.subscribe("MyCustomEvent", function(msg, list, isSomething) {
			console.log(msg);         // "Hello Subscriber"
			console.log(list);        // [ 12, 15 ]
			console.log(isSomething); // false
		});
		
		
		
		/////////////////////////////////////
		

		console.log(foothold, Tundra.scene);
		var geometry = new THREE.BoxGeometry( 5, 5, 5 );
		var material = new THREE.MeshBasicMaterial( { map: this.videotexture} );
		console.log(geometry);
		var cubeMesh = new THREE.Mesh( geometry, material );
		
		cubeMesh.position.x = 61;
		cubeMesh.position.y = 9.59;
		cubeMesh.position.z = -44;
		cubeMesh.name = "video screen";

		var threeGroup = new THREE.Object3D();
		this.threeGroup = threeGroup;
		this.threeGroup.add(cubeMesh);
		
		cameraEnt.placeable.lookAt(cubeMesh.position);

/* 		url = 'soapbox_foothold.json';

		loader.load(url, function(geometry, materials){
		
			var material = new THREE.MeshBasicMaterial(materials);
			var soapHolderMesh = new THREE.Mesh(geometry, material);
			itself.soapHolderMesh = soapHolderMesh;
			soapHolderMesh.name = "soap_holder";
			soapHolderMesh.position.x = 66.21;
			soapHolderMesh.position.y = 9.59;
			soapHolderMesh.position.z = -44;
			itself.threeGroup.add(soapHolderMesh);
		}); */

		Tundra.renderer.scene.add(threeGroup);
		console.log(Tundra.renderer.scene);

		/* render dynamic objects one by one */
		requestAnimationFrame(function animation(){
		
			onRenderFctsWithoutParam.forEach(function(onRenderFctsWithoutParam){
				onRenderFctsWithoutParam();
			})
			requestAnimationFrame(animation);
		})
		console.log(Tundra.renderer.scene);
    },
	/* update video state */
	videoTextureUpdate : function()
	{
		if( this.video.readyState !== this.video.HAVE_ENOUGH_DATA )	
			return;
		this.videotexture.needsUpdate	= true;	
	},
	
	getListOfMeshObj : function()
	{
		var arr = [];
		Tundra.renderer.scene.traverse(function(object)
		{
			if(object instanceof THREE.Mesh)
				arr.push(object);
		}, function(error)
		{
			console.log("getting list of object failed");
		});
		if(arr.length !== 0)
			return arr;
		else
			return false;

		
	},
	
	rayCast : function()
	{	
		var rayCastEnt = Tundra.renderer.raycast();
		var threeRacaster = Tundra.renderer.raycaster;
		var obj = threeRacaster.intersectObjects(this.listOfMeshObject);
		
		if(obj)
		{
			var raycastData;
			this.raycastData = obj;
			this.entity.exec(EntityAction.Local, _MSG_RAYCAST);
		}
	},
	rayCastForThreeObj : function()
	{
	},
	
	object : function(entityAction)
	{
		if (entityAction.name === _MSG_RAYCAST)
		{
			console.log(entityAction);
		}
	},

    /** 
        Script destroy/unload handler. Called automatically 
        by the framework when the application is closed.
    */
    onScriptDestroyed : function()
    {
        this.log.info("Shutting down");

        // Clean up any UI created by this application.
        if (this.ui && this.ui.welcome)
            this.ui.welcome.remove();
        this.ui = null;
    },

    initUi : function()
    {
        this.ui = {};
        this.ui.baseCSS = {
            "position" : "absolute",
            "padding"  : 25,
            "top" : 25,
            "left" : 25,
            "font-family" : "RobotoDraft, Arial",
            "color" : "white",
            "background-color" : "rgba(8,149,195,0.8)"
        };

        this.ui.welcome = $("<div/>", { text : "Welcome to the 'virtual_test' application" });
        this.ui.welcome.css(this.ui.baseCSS);
        this.ui.welcome.hide();

        this.framework.ui.addWidgetToScene(this.ui.welcome);
        this.ui.welcome.fadeIn(5000);
    },

    onEntityAction : function (entityAction)
	{
        if (entityAction.name === _MSG_INTRODUCTION)
        {
            this.log.info("Server messaged it is ready");
        }
		else if (entityAction.name === _MSG_RAYCAST)
		{
			//this.log.info("rayyyy");
		}
    },
	
    haejongAsset : function (asset)
	{
        var obj = asset.data;
		console.log(obj);
        //console.log( "hotspot length is "+obj.hotspots.length );
		
/* 		var entity = Tundra.scene.createLocalEntity(["Name", "Mesh", "Placeable"]);
		entity.name = "soapbox_footbold";

		entity.mesh.meshRef = "local://soapbox_foothold.mesh";
		entity.mesh.materialRefs = ["local://soapbox_foothold.material"];
		
		entity.placeable.setPosition(new THREE.Vector3(66.21,9.59,-44));
		entity.placeable.setScale(new THREE.Vector3(1, 1, 1));
		entity.placeable.setRotation(new THREE.Vector3(0, 52, 0));
		
		console.log(entity); */
		//Tundra.scene.update();
		
		
		var entity = Tundra.scene.createLocalEntity(["Name", "Mesh", "Placeable", "RigidBody"]);
		entity.name = "hotpot";

		entity.mesh.meshRef = "http://tundra-blueshift.s3.amazonaws.com/koste/ubihotspot/Cube.001.mesh";
		entity.mesh.materialRefs = [
			"http://tundra-blueshift.s3-eu-west-1.amazonaws.com/koste/ubihotspot/sides.material",
			"http://tundra-blueshift.s3-eu-west-1.amazonaws.com/koste/ubihotspot/front.material",
			"http://tundra-blueshift.s3-eu-west-1.amazonaws.com/koste/ubihotspot/back.material"
		];
		
		entity.placeable.setPosition(new THREE.Vector3(70.2041016,7.68280506,-44.3602066));
		entity.placeable.setScale(new THREE.Vector3(1, 1, 1));
		entity.placeable.setRotation(new THREE.Vector3(0, 52, 0));
		console.log(entity);
		console.log(this);
		return entity;
    }
	
});
// Start the application by instantiating it
var webRocketApplication = new WebRocketApplication();