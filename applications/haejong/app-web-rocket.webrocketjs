var _MSG_INITIATION    = "MSG_client_initiation";


/* SYSTEM MESSAGES */
var _MSG_SPEECH_BEGIN			= "speech_started";
var _MSG_SPEECH_BEGIN_REQUEST	= "speech_begin_request";
var _MSG_SPEECH_END 			= "speech_ended";
var _MSG_SPEECH_END_REQUEST		= "speech_end_request";
var _MSG_RAYCAST 				= "MSG_intersected_objects";
var _MSG_MOUSE_PRESS			= "MSG_mouse_press";
var _MSG_MOUSE_RELEASE			= "MSG_mouse_release";
var _MSG_MOUSE_HOVER			= "MSG_mouse_hover_object";
var _MSG_COMMENTS				= "MSG_recieved";
var _MSG_BROADCAST				= "MSG_broadcast";
var _MSG_SEARCH_USER			= "MSG_search_request";
var _MSG_FOUND_USER				= "MSG_found_response";
var _MSG_NOT_FOUND_USER 		= "MSG_not_found_response";
var _MSG_VOTE					= "MSG_user_vote";
var _MSG_USER_TELEPORT_REQ 	 	= "MSG_teleport";
var _MSG_USER_JOINED_VENUE		= "MSG_user_joined";
var _MSG_USER_LEFT_VENUE		= "MSG_user_left";

// the area for speech venue 
//var SET_AREA_FOR_SPEECH_FROM  = {"x":55, "z":-50};
//var SET_AREA_FOR_SPEECH_TO  = {"x":60, "z":-39};
var SET_AREA_FOR_SPEECH_FROM  = {"x":52, "z":-55};	// covers larger area as the venue
var SET_AREA_FOR_SPEECH_TO  = {"x":70, "z":-34};
var POSITION_SCREEN_DEFAULT  = {"x":60.21, "y":9.50, "z":-44.35};

var AREA_FOR_SPEAKER_ONLY_FROM = {"x":66.5, "y":9, "z":-43.9};
var AREA_FOR_SPEAKER_ONLY_TO = {"x":67.7, "y":20, "z":-42.8};

var SOAPBOX_NAME = "http://localhost:8082/applications/haejong/soapbox.mesh_submesh_0";
var PATH_TO_REGISTRATION = "speaker22/index.html";
var GEO_SCREEN_DEFAULT = {"v1":0.01, "v2":2, "v3":2};
var GEO_BUTTON_DEFAULT = {"v1":1, "v2":1, "v3":1};
var POSITION_REPORT_DEFAULT = {"x":63.20, "y":8.10, "z":-37.36};
var POSITION_LIKE_DEFAULT = {"x":63.20,"y":8.10,"z":-46.36}
var POSITION_DISLIKE_DEFAULT = {"x":63.20,"y":8.10,"z":-42.36};
var POSITION_DEFAULT = {"x":50.20, "y":9.59, "z":-33.36};
var HEX_LIKE = 0x00ff00;
var HEX_DISLIKE = 0x6600ff;
var HEX_REPORT = 0xff0000;

var WebRocketApplication = IApplication.$extend(
{
    __init__ : function()
    {
// NOT USED  -- LOADING .JSON OBJECT
/* 		url = './localAssets/soapbox_foothold.json';

		loader.load(url, function(geometry, materials){
		
			var material = new THREE.MeshBasicMaterial(materials);
			var soapHolderMesh = new THREE.Mesh(geometry, material);
			itself.soapHolderMesh = soapHolderMesh;
			soapHolderMesh.name = "soap_holder";
			soapHolderMesh.position.x = 66.21;
			soapHolderMesh.position.y = 9.59;
			soapHolderMesh.position.z = -44;
			itself.threeGroup.add(soapHolderMesh);
		}); */
		
		console.log(Physijs);
		
		var self = this;
        this.$super("soapbox_virtual");
		console.log("client connected");
		
		// user id
		var userName = Tundra.client.loginProperties.username;
		var userInfo = {"name" : userName, "id" : "", "avatarName" : ""};
		this.userInfo = userInfo;
		console.log(this.userInfo);

		this.initUi(self);
		
		var onRenderFctsWithoutParam = [];
		var onRenderFctsWithParams = [];
		var listOfMeshObject = [];
		var listOfThreeGroup = [];
		var raycastData;		
		var isSpeechOn;
		var speakerInfo;
		var toVote = 1;
		
		var numOfUsersInTheVenue = 0; // except me
		this.numOfUsersInTheVenue = numOfUsersInTheVenue;
		var isUserInTheVenue = 0;
		this.isUserInTheVenue = isUserInTheVenue;	
		this.speakerInfo = speakerInfo;
		this.toVote = toVote;

		/* Tundra entities */
		var foothold = Tundra.scene.entityByName("soapbox_footbold");
		this.foothold = foothold;
		var video;
		
		/* THREE */
		var videoTexture = new THREE.Texture(video);
		this.videoTexture = videoTexture;
		var threeMeshGroup = new THREE.Object3D();
		this.threeMeshGroup = threeMeshGroup;
		
		// textures
		tex = THREE.ImageUtils.loadTexture("./localAssets/like.jpg");
		texture_waiting = THREE.ImageUtils.loadTexture("./localAssets/waiting.jpg", function(error){
			console.log(this,"image not loaded, error");
		});
		this.texture_waiting = texture_waiting;
		
		// create the plane mesh
		/*var material = new THREE.MeshBasicMaterial({ wireframe: true });
		var geometry = new THREE.PlaneGeometry();
		var planeMesh= new THREE.Mesh( geometry, material );
		// add it to the WebGL scene
		this.threeMeshGroup.add(planeMesh);
		planeMesh.position.x = 55;
		planeMesh.position.y = 9;
		planeMesh.position.z = -44;*/
		
		////////////////////////////////////
		//* create objects for the scene *//
		////////////////////////////////////
		
		var url = []; 
		var objPosition = [];
		var geo = [];
		
		var screenMesh = this.createCubeObj(this.videoTexture, "video_screen", POSITION_SCREEN_DEFAULT, geo);
		this.screenMesh = screenMesh;
		url = './localAssets/ic_sentiment_satisfied_black_24dp/web/ic_sentiment_satisfied_black_24dp_2x.jpg'; 

		var btnMesh = this.createBtnObj(url, "likeBtn", POSITION_LIKE_DEFAULT, GEO_BUTTON_DEFAULT); // create likeBtn
		
		url = './localAssets/ic_sentiment_dissatisfied_black_24dp/web/ic_sentiment_dissatisfied_black_24dp_2x.jpg'; 	
		var btnMesh2 = this.createBtnObj(url, "disLikeBtn", POSITION_DISLIKE_DEFAULT, GEO_BUTTON_DEFAULT); // disLikeBtn
		
		url = './localAssets/ic_sentiment_very_dissatisfied_black_24dp/web/ic_sentiment_very_dissatisfied_black_24dp_2x.jpg';
		var reportBtn = this.createBtnObj(url, "reportBtn", POSITION_REPORT_DEFAULT,GEO_BUTTON_DEFAULT)
		// to change texture's emissive attribute
		hexOfBtn1 = this.getHexValue(btnMesh);
		hexOfBtn2 = this.getHexValue(btnMesh2);
 
		// add objects to the three.scene
		Tundra.renderer.scene.add(this.threeMeshGroup);
		console.log(Tundra.renderer);
		console.log(Tundra);
		////* Listeners *////
		// entity event listeners
        this.entity.onEntityAction(this, this.onEntityAction);
		this.foothold.onEntityAction(this, this.onEntityAction);
		
		// mouse event listeners
		var mouseEvents = Tundra.input.onMouseEvent(this, this.onMouseEvent); // function(context, callback) 
		Tundra.events.subscribe(_MSG_MOUSE_PRESS, this, this.onMousePress); 
		Tundra.events.subscribe(_MSG_MOUSE_RELEASE, this, this.onMouseRelease);
		Tundra.events.subscribe(_MSG_MOUSE_HOVER, this, this.onMouseHoverObj);

        // introduce this user to the server
        this.entity.exec(EntityAction.Server, _MSG_INITIATION);
		
		/**************get video stream*******************/
		//https://github.com/jeromeetienne/threex.videotexture/blob/master/examples/videotexture.html
				
		
		/*******************************************/
		
		
		/***********connect to middleware******************/
		
		var virtual = new Virtual();
		this.virtual = virtual;
		
		//handled by middleware when user is logging out
		window.onbeforeunload = function(){virtual.unregister();};	
		
		/**************************************************/

		/* functions to be rendered in a loop */		
		onRenderFctsWithoutParam.push(function()
		{
			self.videoTextureUpdate(); 	// this => window
		});
		
		onRenderFctsWithoutParam.push(function()
		{
			self.raycastData = self.rayCast();				// this => window					
		
		});

		
		// define whether user is near the screen 
		onRenderFctsWithoutParam.push(function(){
			if(self.userInfo.avatarName){
				//console.log(Tundra.scene.entityByName("Avatar1").placeable.transform.pos)
				self.userJoinedVenue(self.userInfo.avatarName);
			}
			
		});
	
		///////////////////////////////////////////////////////

/* 		var newScene = Tundra.renderer.scene.clone(new Physijs.Scene);
		Tundra.renderer.scene = newScene;
		console.log(Tundra.renderer); */

		
		listOfMeshObject = this.getListOfMeshObj();
		this.listOfMeshObject = listOfMeshObject;
		
		// get soapbox obj from meshmoon asset
		// add into threejs scene 
		function getSoapboxObj(element, index, array) {		
		  while (element.name == SOAPBOX_NAME) {
			  return element;
		  }
		}

		var soapboxObj = listOfMeshObject.find(getSoapboxObj);
		this.soapboxObj = soapboxObj;
		
/* 		listOfThreeGroup = this.getListOfObj3D();
		this.listOfThreeGroup = listOfThreeGroup; */
		
		function createCssRenderer() {
			var cssRenderer = new THREE.CSS3DRenderer();
			cssRenderer.setSize(window.innerWidth, window.innerHeight);
			cssRenderer.domElement.style.position = 'absolute';
			cssRenderer.domElement.style.top = 0;
			console.log(cssRenderer);
			return cssRenderer;
		}
	
		function createPlane(w, h, position) {
			var material = new THREE.MeshBasicMaterial({
			  color: 0x000000,
			  opacity: 0.0,
			  side: THREE.DoubleSide
			});
			var geometry = new THREE.PlaneGeometry(w, h);
			var mesh = new THREE.Mesh(geometry, material);
			mesh.position.x = position.x;
			mesh.position.y = position.y;
			mesh.position.z = position.z;
			console.log(mesh);
			return mesh;
		}
		function createCssObject(w, h, position, url) {
			var html = [
			  '<div style="width:' + w + 'px; height:' + h + 'px;">',
			  '<iframe src="' + url + '" width="' + w + '" height="' + h + '">',
			  '</iframe>',
			  '</div>'
			].join('\n');
			var div = document.createElement('div');
			$(div).html(html);
			var cssObject = new THREE.CSS3DObject(div);
			cssObject.position.x = position.x;
			cssObject.position.y = position.y;
			cssObject.position.z = position.z;
			return cssObject;
		}
		function create3dPage(w, h, position, url) {
			var plane = createPlane(w, h, position);
			console.log(plane);
			threeMeshGroup.add(plane);
			var cssObject = createCssObject(w, h, position, url);
			console.log(cssObject);
			//threeMeshGroup.add(cssObject);
			cssScene.add(cssObject);
		}
		
		
		
		// important
		var cssRenderer = createCssRenderer();
		/*var webb = document.createElement('webb');
		this.webb = webb;
		this.webb.className = "webb";
		this.webb.id = "webb";
		
        $(this.webb).css({
            position: "absolute",
            width: "300px",
            height: "100%",
            right: "0px",

        });*/
		//document.body.appendChild(glRenderer.domElement);
		//document.body.appendChild(cssRenderer.domElement);
		//cssRenderer.domElement.appendChild(glRenderer.domElement);
		//initPolymer(cssRenderer);
		cssScene = new THREE.Scene();
		create3dPage(10, 10, POSITION_DEFAULT, 'http://www.oulu.fi/english/');
		Tundra.renderer.cssRenderer = cssRenderer;
		Tundra.renderer.cssRendererScene = cssScene;
		console.log(Tundra.renderer);
		console.log(TundraSDK.framework.client);

		// loop for video render etc.
		// im thinking this function title is not predetermined
		requestAnimationFrame(function animation()
		{
			var len = onRenderFctsWithoutParam.length;
			if(len !== 0)
			{
				onRenderFctsWithoutParam.forEach(function(onRenderFctsWithoutParam)
				{
					onRenderFctsWithoutParam();
				});
			}
			if(len !== 0)
			{
				onRenderFctsWithParams.forEach(function(onRenderFctsWithParams)
				{
					if(onRenderFctsWithParams.length === 1)
						onRenderFctsWithParams();
					else if(onRenderFctsWithParams.length === 2)
						onRenderFctsWithParams();
					else if(onRenderFctsWithParams.length === 3)
						onRenderFctsWithParams();
				});
			}
			requestAnimationFrame(animation);
		})
		
    },
	

	///////////////////////////////////////////
	//*  this.methods in alphabetical order *//
	///////////////////////////////////////////
	
	addNewComment : function(text, name, id){
		
		var userName = name;
		var text = text;
		
		var commentInnerDiv = document.createElement("div");  // comment holder div
		var comment = document.createElement("b"); // comment text
		
		commentInnerDiv.id = "commentInnerDiv";
		comment.id = "comment";	
		
		$(commentInnerDiv).css({
			position : "relative",
			width : "100%",
			height : "40px",		
		});
		
		$(comment).css({
			position : "relative",
			width : "100%",
			height : "30px",
			color : "black",
			//font-weight : "bold";				
		});			
		
		comment.innerHTML = name + ": " + text;
		
		/* //mouse hover, not used 			
		$(self.userIdInner).mouseover(function(){
			$(self.userIdInner).css("background-color", "red");
		});
		$(self.userIdInner).mouseout(function(){
			$(self.userIdInner).css("background-color", "white");
		});	 */	
		
		var parent = this.dashboard.children["commentDiv"];
		parent.appendChild(commentInnerDiv);
		commentInnerDiv.appendChild(comment);

	},
	
	// open up url for speech registration when virtual user try to do so 
	callRegistration : function(url){
		var _url = url
		_url.replace("watch?v=", "v/");
		window.open(_url, "new");
	},
	
	// change size of the screen accordingly to the number of users in the venue
	changeScreenSize : function(numOfUsers){
		if(numOfUsers >= 1){
			this.screenMesh.scale.set(0.01, 4, 4); // will be pre-defined
			this.screenMesh.position.y = 12.50;
		}else if(numOfUsers == 0){
			this.screenMesh.scale.set(GEO_SCREEN_DEFAULT.v1, GEO_SCREEN_DEFAULT.v2, GEO_SCREEN_DEFAULT.v3);		// will be pre-defined
			this.screenMesh.position.y = POSITION_SCREEN_DEFAULT.y;
		}
		console.log("screen size change " + numOfUsers);
	},
	
	createBtnObj : function(url, name, initPosition, geo){

		if(!url){
			console.log("error, no url of texture for the obj");
			return;
		}else if(typeof name == 'undefined'){
			console.log("this obj has given no name");
			var name = '';
		}else if(typeof initPosition == 'undefined'){
			console.log("warning, initial coordinate has not given, will be set as default value: 55, 9, -44");
			var initPosition = [];
		}else if(typeof geo == 'undefined'){
			console.log("warning, initial geometry value has not given, will be set as default value: 2, 2, 2");
			var geo = [];
		}
		
		var btnTexture = THREE.ImageUtils.loadTexture(url, function(error){
			console.log(this,"image not loaded, error");
		});

		var btnMaterial = new THREE.MeshLambertMaterial({map: btnTexture});
		var btnGeometry = new THREE.BoxGeometry(geo.v1 ? geo.v1 : GEO_SCREEN_DEFAULT.v1
		, geo.v2 ? geo.v2 : GEO_SCREEN_DEFAULT.v2
		, geo.v3 ? geo.v3 : GEO_SCREEN_DEFAULT.v3);
		var btnMesh = new THREE.Mesh( btnGeometry, btnMaterial );
		
		btnMesh.name = name;
		btnMesh.position.x = initPosition.x ? initPosition.x : 55;
		btnMesh.position.y = initPosition.y ? initPosition.y : 9;
		btnMesh.position.z = initPosition.z ? initPosition.z : -44;
		console.log(btnMesh);
		this.threeMeshGroup.add(btnMesh);
		
		return btnMesh;

	},
	
	createCubeObj : function(texture, name, initPosition, geo){
		if(!texture){
			console.log("error, no url of texture for the obj");
			return false;
		}else if(typeof texture == 'string'){
			var texture = THREE.ImageUtils.loadTexture(texture, function(error){
				console.log(this,"image not loaded, error");
			});
		}	
		if(typeof name == 'undefined'){
			console.log("this obj has given no name");
			var name = "";
		}else if(typeof initPosition == 'undefined'){
			console.log("warning, initial coordinate has not given, will be set as default value: 55, 9, -44");
			var initPosition = [];
		}else if(typeof geo == 'undefined'){
			console.log("warning, initial geometry value has not given, will be set as default value: 2, 2, 2");
			var geo = [];
		}
		var geometry = new THREE.BoxGeometry(geo[0] ? geo[0] : 2, geo[1] ? geo[1] : 2, geo[2] ? geo[2] : 2);
		console.log(texture);
		var material = new THREE.MeshLambertMaterial({ map: texture});
		var cubeMesh = new THREE.Mesh(geometry, material);	
		
		cubeMesh.name = name;
		cubeMesh.position.x = initPosition.x ? initPosition.x : 55;
		cubeMesh.position.y = initPosition.y ? initPosition.y : 9;
		cubeMesh.position.z = initPosition.z ? initPosition.z : -44;

		this.threeMeshGroup.add(cubeMesh);
		
		return cubeMesh;
	},
	
	isSpeakerMe : function(){
		if(typeof this.userInfo == 'undefined' | typeof this.speakerInfo == 'undefined'){
			console.log("User information or current Speaker information is not known to the system");
			return false;
		}
		
		var userId = this.userInfo.id;
		var speakerId = this.speakerInfo.speakerInfo[0].generalInfo.id;
		
		if(userId == speakerId){
			console.log("this user is the speaker");
			return true;
		}else{
			console.log("this user is not the speaker");
			return false;
		}
	},
	
	getHexValue : function(obj){
		return obj.material.emissive.getHex();
	},
	
	getListOfMeshObj : function(){
		var arr = [];
		Tundra.renderer.scene.traverse(function(object)
		{
			if(object instanceof THREE.Mesh)
				arr.push(object);
		}, function(error)
		{
			console.log("getting list of object failed");
		});
		console.log(arr);
		if(arr.length !== 0)
			return arr;
		else
			return false;

		
	},
	
	getListOfObj3D : function(){
		var arr = [];
		Tundra.renderer.scene.traverse(function(object)
		{
			if(object instanceof THREE.Object3D)
				arr.push(object);
		}, function(error)
		{
			console.log("getting list of object failed");
		});
		if(arr.length !== 0)
			return arr;
		else
			return false;
		
	},
	
    initUi : function(self){
        this.ui = {};
        this.ui.baseCSS = {
            "position" : "absolute",
            "padding"  : 25,
            "top" : 25,
            "left" : 25,
            "font-family" : "RobotoDraft, Arial",
            "color" : "white",
            "background-color" : "rgba(8,149,195,0.8)"
        };

        this.ui.welcome = $("<div/>", { text : "Welcome to the 'virtual_test' application" });
        this.ui.welcome.css(this.ui.baseCSS);
        this.ui.welcome.hide();

        this.framework.ui.addWidgetToScene(this.ui.welcome);
        this.ui.welcome.fadeIn(2000);
		
		/*************dashboard UI********************************/
		
		// dashboard
	    var dashboard = document.createElement('dashboard');
		this.dashboard = dashboard;
		this.dashboard.className = "dashboard";
		this.dashboard.id = "dashboard";
		
        $(this.dashboard).css({
            position: "absolute",
            "background-color" : "black",
            width: "300px",
            height: "100%",
            right: "0px",
			//opacity: 0.5,
			//filter: "alpha(opacity=50)" /* For IE8 and earlier */
        });
		//this.dashboard.style.overflow = "scroll";
		
		document.body.appendChild(this.dashboard);
		
		// vote status panel
		var votePanel = document.createElement("div");
		votePanel = votePanel;
		votePanel.id = "votePanel";
		
		$(votePanel).css({
		    position: "absolute",
            "background-color" : "white",
            width: "100%",
            height: "40px",
			top : "20px"

		});
		
		this.dashboard.appendChild(votePanel);
		
		// like and dislike
		var voteType = document.createElement("b");
		voteType.id = "voteType";			
		$(voteType).css({
			position : "relative",
			height : "50%",
			color : "black",
			left : "30px"
			//font-weight : "bold"				
		});	
	
		votePanel.appendChild(voteType);
			
		// comment text input
		var txtInput = document.createElement("input");
		txtInput.setAttribute("type", "text");
		txtInput.id = "commentInput"
		
		$(txtInput).css({
		    position: "absolute",
            "background-color" : "white",
            width: "100%",
            height: "30px",
			bottom : "100px"

		});
		
		this.dashboard.appendChild(txtInput); // put it into the DOM
		
		// send comment button
		var sendCommBtn = document.createElement("button");		
		sendCommBtn.appendChild(document.createTextNode("Send comment"));
		sendCommBtn.setAttribute("type", "button");
		sendCommBtn.id = "commentBtn";
		
		$(sendCommBtn).css({
			position : "absolute",
			"background-color" : "white",
			bottom : "55px",
			width: "100px",
			left : "30px"
			
		});
		this.dashboard.appendChild(sendCommBtn);
			
		// teleport to the speech venue
		var teleportBtn = document.createElement("button");

		teleportBtn.appendChild(document.createTextNode("Teleport to the speech"));
		teleportBtn.setAttribute("type", "button");
		teleportBtn.id = "teleportBtn";
		
		$(teleportBtn).css({
			position : "absolute",
			"background-color" : "white",
			bottom : "55px",
			width: "100px",
			right : "20px"
			
		});
		this.dashboard.appendChild(teleportBtn);
		
		// div for comment area
		var commentDiv = document.createElement("div");
		commentDiv.id = "commentDiv";
		commentDiv.style.overflowY = "scroll";
		
		$(commentDiv).css({
			position : "absolute",
			bottom : "150px",
			width : "100%",
			height : "50%",
			background : "white",		
		});
		
		this.dashboard.appendChild(commentDiv);	
		
		// comment btn clicked
		$(sendCommBtn).click(function(){
			var v = document.getElementById("commentInput");
			//addNewComment(self, v.value);
			self.virtual.comment(self.userInfo.name, v.value);
			self.entity.exec(EntityAction.Server, _MSG_COMMENTS, v.value);

			v.value == "";
		});
		
		// teleport btn clicked
		$(teleportBtn).click(function(){
			self.onClickTeleport();
		});

		$("dashboard").hide();
		/**********************************************************/
    },
	
	onClickTeleport : function(){
		
		this.entity.exec(EntityAction.Server, _MSG_USER_TELEPORT_REQ, this.userInfo.avatarName);

	},

    onEntityAction : function(entityAction){
		
        if(entityAction.name === _MSG_INITIATION)
		{
			// CLIENT INIT
            this.log.info("Server messaged it is ready");
			
			// user init with init params received from the server
			// speech state, user id determined by server

			this.initParams(JSON.parse(entityAction.parameters[0]));
        }
		else if(entityAction.name === _MSG_BROADCAST)
		{ 
		// entityAction.parameters[0] -> text
		// entityAction.parameters[1] -> user name
		// entityAction.parameters[2] -> user id
			this.addNewComment(entityAction.parameters[0], entityAction.parameters[1], entityAction.parameters[2]);
		}
		// entityAction.parameters[0] -> entity name
		// entityAction.parameters[1] -> entity id
		else if(entityAction.name === _MSG_SPEECH_BEGIN)
        {
			this.speakerInfo = JSON.parse(entityAction.parameters[0]);
			this.initVideo(this);
			this.setVideoMedia(this, this.video);
			// name, id, entity name, entity id
			this.setSpeechBegin(entityAction.parameters[0]);
        }
		else if(entityAction.name === _MSG_SPEECH_BEGIN_REQUEST)
		{
			// send request to the speaker to fill the speech info
			var speechTitle = this.setSpeechInfo();
			if(speechTitle != false){
				this.entity.exec(EntityAction.Server, _MSG_SPEECH_BEGIN_REQUEST, speechTitle); // param : speech title 
			}	
			
		}
		else if(entityAction.name === _MSG_SPEECH_END)
        {
			// name, id, entity name, entity id
			this.setSpeechEnd(entityAction.parameters[0]);
        }
		else if(entityAction.name === _MSG_SPEECH_END_REQUEST)
		{
			this.prompSpeechMsg(2); // confirm if speaker wants to end the speech
		}
		// find user request
		else if(entityAction.name === _MSG_FOUND_USER)
        {
        }
		else if(entityAction.name === _MSG_NOT_FOUND_USER)
        {
			
        }
		// user enter/leave the speech area
		else if(entityAction.name === _MSG_USER_JOINED_VENUE)
		{
			this.numOfUsersInTheVenue = entityAction.parameters[0];
			this.changeScreenSize(entityAction.parameters[0]);
		}
		else if(entityAction.name === _MSG_USER_LEFT_VENUE)
		{
			this.numOfUsersInTheVenue = entityAction.parameters[0];
			this.changeScreenSize(entityAction.parameters[0]);
		}			
		// raycast tundra objects
		else if(entityAction.name === _MSG_RAYCAST)
		{
			//TODO

			Tundra.events.send(_MSG_MOUSE_HOVER);
				//console.log(this.raycastData[0].object.name);
			
		}
		else if(entityAction.name === _MSG_VOTE)
		{
			this.refreshVote(entityAction.parameters[0], entityAction.parameters[1]); // like, dislike
		}
    },
	
	onMouseEvent : function(event){
		// set live coordinate of the mouse
		var x;
		var y;
		this.x = event.x;
		this.y = event.y;
		
		if(event.type === "press"){
			Tundra.events.send(_MSG_MOUSE_PRESS, event);
		}
		if(event.type === "release"){
			Tundra.events.send(_MSG_MOUSE_RELEASE, event);
		}
	},
	
	onMouseHoverObj : function(){
		var hoverObj = this.raycastData;
			
		if(hoverObj == '' | typeof hoverObj == 'undefined'){return;}
		else{
			var objLen = hoverObj.length;
			for(var i=0; i<objLen; i++){
				var obj = hoverObj[i].object; // get name of obj in which current mouse is upon
				
				// find vote blocks
				if(this.toVote & this.isSpeechOn){
					if(obj.name == 'likeBtn' | obj.name == 'disLikeBtn' | obj.name == 'reportBtn'){
						if(obj.name == 'likeBtn'){
							// 0 otherwise use getHexValue() to store inital hexvalue of the obj
							this.setHexValue(obj, HEX_LIKE, "disLikeBtn", 0); 
							return;
						}else if(obj.name == 'disLikeBtn'){
							this.setHexValue(obj, HEX_DISLIKE, "likeBtn", 0);
							return;
						}else if(obj.name == 'reportBtn'){
							this.setHexValue(obj, HEX_REPORT, "disLikeBtn", 0);
							return;
						}
					}else{
						// set back the colour 
						this.setHexValueBack("likeBtn", 0);
						this.setHexValueBack("disLikeBtn", 0);
						this.setHexValueBack("reportBtn", 0);
					}
				}else{ 
				// find vote blocks, will be made a method in a near future		
				}				
				// find soapbox
				if(obj.name == SOAPBOX_NAME){
					this.setHexValue(obj, 996633);
					return;
				}else{  // when mouse leaves soapbox
					if(typeof this.soapboxObj == 'undefined'){
						return;
					}else{
						// also need to be optimized
						this.setHexValue(this.soapboxObj, 0); // for some reason setHexValueBack() doesn't work
						//this.setHexValueBack(this.soapbox_obj, 0);  // set back colour of soapbox to normal
					}
				}
				
				// find other obj if needed
			}
		}	
	},
	//// not working for some reason
/* 	onMouseHoverBtn : function(obj){
		// find mouse hover on voting blocks
		if(obj.name == 'likeBtn' | obj.name == 'disLikeBtn'){
			if(obj.name == 'likeBtn'){
				console.log("im on likeBtn");
				this.setHexValue(obj, 0x00ff00, "disLikeBtn", this.hexOfBtn2);
				return;
			}else if(obj.name == 'disLikeBtn'){
				console.log("im on disLikeBtn");
				this.setHexValue(obj, 0xff0000, "likeBtn", this.hexOfBtn1);
				return;
			}
		}else{
			// set back the colour 
			this.setHexValueBack("likeBtn", this.hexOfBtn1);
			this.setHexValueBack("disLikeBtn", this.hexOfBtn2);
		}		
	}, */
	
	onMousePress : function(event){		
		var objTargetted;	
		console.log(event.type)
		console.log(event);
		objTargetted = this.rayCast();
		
		if(objTargetted)
		{
			var objLen = objTargetted.length;
			for(var i=0; i<objLen; i++)
			{
				console.log(objTargetted[i].object.name);
				var obj = objTargetted[i].object;
				// user votes
				this.onMousePressBtn(obj);
				this.onMousePressSoapbox(obj)
			}
		}
		//TODO		
	},
	
	onMousePressBtn : function(obj){
		// recognize buttons when only a speech is on 
		if(this.toVote & this.isSpeechOn){
			if(obj.name == 'likeBtn' | obj.name == 'disLikeBtn'){
				if(obj.name == 'likeBtn'){
					// vote like
					this.onVote(1);
					this.virtual.like();		// temp 
					this.setHexValueBack("likeBtn", 0);

					
				}else if(obj.name == 'disLikeBtn'){
					// vote dislike
					this.onVote(0);
					this.virtual.dislike();		// temp
					this.setHexValueBack("disLikeBtn", 0);
				}
			}
		}		
	},
	
	onMousePressSoapbox : function(obj){
		// when user press the soapbox
		if(obj.name == SOAPBOX_NAME){  
			console.log("soapbox clicked");
			this.callRegistration(PATH_TO_REGISTRATION);
		}
		
	},
	
	// user vote on the speaker
	onVote : function(vote){
		var vote = vote;
		this.toVote = 0;
		if(vote){
			console.log("you liked the speech");
			this.entity.exec(EntityAction.Server, _MSG_VOTE, vote);
			
		}else{
			console.log("you disliked the speech");
			this.entity.exec(EntityAction.Server, _MSG_VOTE, vote);
		}
			
	},
		
	onMouseRelease : function(event){	
		console.log(event.type)
		// TODO 
	},
	
	prompSpeechMsg : function(action){
		if(action == 1){ // send msg to all users that speech has started
			if (confirm("A speech is about to begin! Click 'ok' to teleport to the venue") == true) {
				this.onClickTeleport();
			} else {}
			// action = 2 -> speech trigger and end related action
		}else if(action == 2){
			console.log("server noticed speaker tries to leave the soapbox");
			var ans = this.prompMsg();
			if (ans == true) {
				// speaker agrees to end the speech
				this.entity.exec(EntityAction.Server, _MSG_SPEECH_END_REQUEST, 1);
				
			} else if (ans == false) {
				// end attempt was a mistake 
				this.entity.exec(EntityAction.Server, _MSG_SPEECH_END_REQUEST, 0);
			}
		}
	
	},
	
	prompMsg : function(){
		return confirm("Would you like to end the speech?");
	},
	
	rayCast : function(){	
	
		var rayCastEnt = Tundra.renderer.raycast();
		var threeRaycaster = Tundra.renderer.raycaster;
		var obj = threeRaycaster.intersectObjects(this.listOfMeshObject);
		if(obj)
		{
			this.entity.exec(EntityAction.Local, _MSG_RAYCAST);
			return obj;
		}
		
		return false;
	},
	
	refreshVote : function(like, dislike){

		if(typeof like == 'undefined'){
			like = 0;
		}else if(typeof dislike == 'undefined'){
			dislike = 0;
		}
		
		// refresh vote state
		this.dashboard.children["votePanel"].children["voteType"].innerHTML = "like: " + like + "  " + "dislike: " + dislike;
	},	
	
	removeVotePanel : function(){
		// empty the vote panel
		this.dashboard.children["votePanel"].children["voteType"].innerHTML = ""; 
	},
	
	setDynamicObjScale : function(obj, scale){
		var geoX = scale.x;
		var geoY = scale.y;
		var geoZ = scale.z;
		
	},
	
	setHexValue : function(obj, toHexValue, nearObj, toHexValueSec){	
		if(typeof nearObj == "undefined"){
			try{
				obj.material.emissive.setHex(toHexValue);	
			}catch(err){
				console.log("no emissive value on this object");
			}
		}else if(typeof nearObj == "string"){
			obj.material.emissive.setHex(toHexValue);
			var secondObj = this.threeMeshGroup.getObjectByName(nearObj);
			secondObj.material.emissive.setHex(toHexValueSec);
		}else{
			obj.material.emissive.setHex(toHexValue);
			nearObj.material.emissive.setHex(toHexValueSec);
		}
	},
		
	setHexValueBack : function(obj, toHexValue){	
		if(typeof obj == 'undefined'){
			return false; 
		}else if(typeof obj == "string"){
			var obj = this.threeMeshGroup.getObjectByName(obj);
			obj.material.emissive.setHex(toHexValue);
		}else{
			obj.material.emissive.setHex(toHexValue);
		}
	},
		
	setSpeechBegin : function(infoData){	
		this.isSpeechOn = 1; // speech is off state
		this.toVote = 1;	// right to vote refreshed
		this.speakerInfo = JSON.parse(infoData);
		
		console.log("speech begins by: " + this.speakerInfo.speakerInfo[0].generalInfo.name);
		
		// speaker himself should not have a teleport button
		var obj = this.threeMeshGroup.getObjectByName("video_screen");
		console.log(obj);

		if(this.isSpeakerMe()){
			this.dashboard.children["teleportBtn"].hidden = true;
			//If it wants to start a speech right now
			console.log(this.video);			
		}else{
			// this user is not the speaker 
			this.dashboard.children["teleportBtn"].hidden = false;
			//this.prompSpeechMsg(1);	// notify users that speech will soon begin
		}	
		$("dashboard").show();
	},	
	
	setSpeechEnd : function(infoData){
		this.isSpeechOn = 0; // speech is off state
		this.toVote = 1; // right to vote refreshed
		this.speakerInfo = JSON.parse(infoData);		
		console.log("speech ends by: " + this.speakerInfo.speakerInfo[0].generalInfo.name);
		this.removeVotePanel();
		
		// stop soapbox 
		this.virtual.stop();
		$("dashboard").hide();
		this.video.pause();
		this.screenMesh.material.map = this.texture_waiting;		
	},
	
	setSpeechInfo : function(){	
		var title = prompt("Enter a title for speech");
    
		if (title != null) {
			return title;
		}else{
			confirm("Enter a title to begin the speech");
			return false;
		}
	},
	
	setVideoMedia : function(context, video){
		//chrome
		if(navigator.webkitGetUserMedia){
			console.log("passing navigator");
			navigator.webkitGetUserMedia(
			{
				video:true,
				audio:true
			},
			function(blob)
			{
				console.log("passing blob");
				//context.virtual.start(blob, submit_info);	// trial
				if(context.isSpeakerMe()){
					video.src = window.URL.createObjectURL(blob);
					// speech started
					var lefttime = current_time_string(); 		//Example: "21/02/2016 12:05"
					var speech_info = {"name": "Jilin", "topic": "New speech", "lefttime": lefttime, "password": "abcdefg123"};
					context.virtual.start(blob, speech_info); 
					console.log("i am a speaker");
					console.log(blob);
				}else{
					console.log("i am an audience");
					video.src = blob;
					console.log(blob);
				}
				console.log(video);
				video.play();
			},
			function(error)
			{
				alert('you have got no WebRTC webcam');
			});
			
		// firefox
		}else if(navigator.mozGetUserMedia){
			navigator.mozGetUserMedia({
				video:true,
				audio:true
			},
			function(blob)
			{
				//context.virtual.start(blob, submit_info);	// trial
				if(context.isSpeakerMe()){
					video.src = window.URL.createObjectURL(blob);
					// speech started
					var lefttime = current_time_string(); 		//Example: "21/02/2016 12:05"
					var speech_info = {"name": "Jilin", "topic": "New speech", "lefttime": lefttime, "password": "abcdefg123"};
					context.virtual.start(blob, speech_info); 
					console.log("i am a speaker");
					console.log(blob);
				}else{
					console.log("i am an audience");
					video.src = blob;
					console.log(blob);
				}
				console.log(video);
				video.play();
			},
			function(error)
			{
				alert('you have got no WebRTC webcam');
			});
		}else
			console.log("video streaming failed");
		
	},
		
	// define whether user is near the screen
	userJoinedVenue : function(avatarName){
		var ent;	
		//ent.addEventLisener(test, this.fun);
		ent = Tundra.scene.entityByName(avatarName);
		if(ent){
			var x = ent.placeable.transform.pos.x;
			var y =	ent.placeable.transform.pos.y;
			var z = ent.placeable.transform.pos.z;
		}		
		if((SET_AREA_FOR_SPEECH_FROM.x < x&x < SET_AREA_FOR_SPEECH_TO.x)&(SET_AREA_FOR_SPEECH_FROM.z < z&z < SET_AREA_FOR_SPEECH_TO.z)){
			if(this.isUserInTheVenue == 0){
				this.isUserInTheVenue = 1;
				this.entity.exec(EntityAction.Server, _MSG_USER_JOINED_VENUE, this.userInfo.id);
				console.log("you are in !!!!!");
				//ent.dispatchEvent(test);
			}
		}else{
			if(this.isUserInTheVenue == 1){
				this.isUserInTheVenue = 0;
				this.entity.exec(EntityAction.Server, _MSG_USER_LEFT_VENUE, this.userInfo.id);
				console.log("you are out !!!!!");
			}
		}
		//console.log(ent.placeable.transform.pos.x + " " + ent.placeable.transform.pos.y + " " + ent.placeable.transform.pos.z);
		
	},

	videoTextureUpdate : function(){
		try{
			if(this.video.readyState !== this.video.HAVE_ENOUGH_DATA)
				return;
			this.videoTexture.needsUpdate = (this.isSpeechOn == 0) ? false : true;
		}catch(e){
			//console.log("video is not ready");
		}
		//console.log(this.videoTexture);
	},
	
	initMiddlewareCallbacks : function(){
		//Register callbacks
		this.virtual.onreceivespeechinfo = function(speech_info) {};
		this.virtual.onreceivecomment = function(username, comment) {"middleware sent: "+console.log(username, comment)};
		this.virtual.onreceivelikes = function(likes){"middleware sent: "+console.log(likes)};
		this.virtual.onreceivedislikes = function(dislikes){"middleware sent: "+console.log(dislikes)};
		this.virtual.onreceivereports = function(reports){};
		this.virtual.onreceivecurrentusers = function(users){};  //TODO - using online and offline in virtual to handle this inf	
	},
	
	// init with params which sent from the server
	initParams : function(initObj){
		console.log("current speech state: "+initObj.speechState);
		this.isSpeechOn = initObj.speechState; 					// init speech state
		this.userInfo.id = initObj.userId;						// user id issued by server
		this.userInfo.avatarName = "Avatar" + initObj.userId;   // user avatar entity name
		var actUserCnt = initObj.actUserCnt;					// users count who are possibly watching the speech
		
		console.log(this.userInfo);
		console.log("active user count: "+ actUserCnt);
		
		this.initMiddlewareCallbacks(); // init callbacks in middleware
		// register this avatar entity to the listeners
		try{
			var avatarEnt = Tundra.scene.entityByName(this.userInfo.avatarName);
			avatarEnt.onEntityAction(this, this.onEntityAction);
			console.log(avatarEnt);
		}catch(e){
			console.log("Warning!!!, your avatar may not be able to trigger the speech");
		}
		// change the screen size according to the count of active users
		this.changeScreenSize(actUserCnt);		
		if(this.isSpeechOn == 0 | typeof this.isSpeechOn == "undefined"){
			this.screenMesh.material.map = this.texture_waiting;
		// if there is a speech going right now
		}else if(this.isSpeechOn == 1){
			// init speaker info if exist
			this.speakerInfo = {"speakerInfo":[{"generalInfo":{"name" : initObj.speakerName, "id" : initObj.speakerId}}
			,{"entityInfo":{"entityName" : initObj.speakerEntityName, "entityId" : initObj.speakerEntityId}}]};
			// init current like/dislike state sent from server
			this.refreshVote(initObj.like, initObj.dislike);
			// init video stream
			this.initVideo(this);
			this.setVideoMedia(this, this.video);
			$("dashboard").show();
		}
	},
	
	initVideo : function(context){
		var video= document.createElement('video');
		this.video = video;
		this.video = video;
		this.video.width = 320;
		this.video.height = 240;
		this.video.autoplay = true;
		this.video.loop = true;
		
		console.log(this.screenMesh);
		//Setup the video object for displaying remote stream
		this.virtual.setup(video);
		this.virtual.connect(function(){context.virtual.register();});
		
		var videoTexture = new THREE.Texture(video);
		context.videoTexture = videoTexture;
		this.screenMesh.material.map = videoTexture;
	}
	

});

// NOT USED
function haejongAsset(asset){

	var entity_soapHolder = Tundra.scene.createLocalEntity(["Name", "Mesh", "Placeable"]);
	var entity_hotspot = Tundra.scene.createLocalEntity(["Name", "Mesh", "Placeable"]);

	entity_soapHolder.name = "soapbox_foothold";
	entity_hotspot.name = "hotpot";

	entity_soapHolder.mesh.meshRef = "local://soapbox_foothold.mesh";
	entity_soapHolder.mesh.materialRefs = ["local://soapbox_foothold.material"];

	entity_hotspot.mesh.meshRef = "local://Cube.001.mesh";
	entity_hotspot.mesh.materialRefs = [
		"local://sides.material",
		"local://front.material",
		"local://back.material"];

	entity_soapHolder.placeable.setPosition(new THREE.Vector3(66.21,9.59,-44));
	entity_soapHolder.placeable.setScale(new THREE.Vector3(1, 1, 1));
	entity_soapHolder.placeable.setRotation(new THREE.Vector3(0, 52, 0));


	entity_hotspot.placeable.setPosition(new THREE.Vector3(70.2041016,7.68280506,-44.3602066));
	entity_hotspot.placeable.setScale(new THREE.Vector3(1, 1, 1));
	entity_hotspot.placeable.setRotation(new THREE.Vector3(0, 52, 0));
	console.log(entity_soapHolder);

}


// TODO: handling keyboard press when starting speech

// Start the application by instantiating it
var webRocketApplication = new WebRocketApplication();