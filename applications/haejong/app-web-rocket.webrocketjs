var _MSG_INITIATION    = "MSG_client_initiation";

//BUGCASE: when speech kicked off while no virtual user is online, virtual server won't have way to latest info ready for virtual user who login later
/* SYSTEM MESSAGES */
var _MSG_SPEECH_BEGIN			= "speech_started";
var _MSG_SPEECH_BEGIN_REQUEST	= "speech_begin_request";
var _MSG_SPEECH_END 			= "speech_ended";
var _MSG_SPEECH_END_REQUEST		= "speech_end_request";
var _MSG_RAYCAST 				= "MSG_intersected_objects";
var _MSG_MOUSE_PRESS			= "MSG_mouse_press";
var _MSG_MOUSE_RELEASE			= "MSG_mouse_release";
var _MSG_MOUSE_HOVER			= "MSG_mouse_hover_object";
var _MSG_COMMENTS				= "MSG_recieved";
var _MSG_BROADCAST				= "MSG_broadcast";
var _MSG_SEARCH_USER			= "MSG_search_request";
var _MSG_FOUND_USER				= "MSG_found_response";
var _MSG_NOT_FOUND_USER 		= "MSG_not_found_response";
var _MSG_VOTE					= "MSG_user_vote";
var _MSG_USER_TELEPORT_REQ 	 	= "MSG_teleport";
var _MSG_USER_JOINED_VENUE		= "MSG_user_joined";
var _MSG_USER_LEFT_VENUE		= "MSG_user_left";
var _MSG_SELECT_COORDINATOR		= "MSG_select_coordinator";
var _MSG_VIDEO_CONFIGURE_FAILED = "MSG_video_failed";
var _MSG_ABORT_SPEECH			= "MSG_abort_speech";
var _MSG_RELEASE_PENDING 		= "MSG_release_pending";

// the area for speech venue 
//var SET_AREA_FOR_SPEECH_FROM  = {"x":55, "z":-50};
//var SET_AREA_FOR_SPEECH_TO  = {"x":60, "z":-39};
var SET_AREA_FOR_SPEECH_FROM  = {"x":52, "z":-55};	// covers larger area later as the venue gets bigger 
var SET_AREA_FOR_SPEECH_TO  = {"x":70, "z":-34};

var SET_AREA_FOR_MIN_VOLUME_FROM  = {"x":22, "z":-85};	// covers larger area later as the venue gets bigger 
var SET_AREA_FOR_MIN_VOLUME_TO  = {"x":100, "z":-4};

var AREA_FOR_SPEAKER_ONLY_FROM = {"x":66, "y":9, "z":-44.2};
var AREA_FOR_SPEAKER_ONLY_TO = {"x":64.8, "y":20, "z":-42.9};

var VOLUME_CHANGE_VALUE = 3;

var SOAPBOX_NAME = "http://localhost:8082/applications/haejong/soapbox.mesh_submesh_0";
var THUMB_UP_NAME = "http://localhost:8082/applications/haejong/Cube_up.mesh_submesh_0";
var THUMB_DOWN_NAME = "http://localhost:8082/applications/haejong/Cube_down.mesh_submesh_0";
var PATH_TO_REGISTRATION = "speaker22/index.html";
var GEO_SCREEN_DEFAULT = {"v1":0.01, "v2":2, "v3":2};
var GEO_BUTTON_DEFAULT = {"v1":1, "v2":1, "v3":1};
var POSITION_REPORT_DEFAULT = {"x":63.20, "y":8.10, "z":-39.36};
var POSITION_LIKE_DEFAULT = {"x":63.20,"y":8.10,"z":-46.36}
var POSITION_DISLIKE_DEFAULT = {"x":63.20,"y":8.10,"z":-42.36};
var POSITION_DEFAULT = {"x":62.50, "y":10, "z":-53.35};
var POSITION_SCREEN_DEFAULT  = {"x":60.21, "y":9.50, "z":-44.35};
var HEX_LIKE = 0x00ff00;
var HEX_DISLIKE = 0x6600ff;
var HEX_REPORT = 0xff0000;
var TIME_LIMIT_VALUE = 10;
var TIME_LIMIT = TIME_LIMIT_VALUE;
var SET_VOLUME_VALUE = 1;
var USER_VOLUME_ZONE = 0;
var USER_POSITION_X;
var USER_POSITION_Z;

var WebRocketApplication = IApplication.$extend(
{
    __init__ : function()
    {
// NOT USED  -- LOADING .JSON OBJECT
/* 		url = './localAssets/soapbox_foothold.json';

		loader.load(url, function(geometry, materials){
		
			var material = new THREE.MeshBasicMaterial(materials);
			var soapHolderMesh = new THREE.Mesh(geometry, material);
			itself.soapHolderMesh = soapHolderMesh;
			soapHolderMesh.name = "soap_holder";
			soapHolderMesh.position.x = 66.21;
			soapHolderMesh.position.y = 9.59;
			soapHolderMesh.position.z = -44;
			itself.threeGroup.add(soapHolderMesh);
		}); */
		
		console.log(Physijs);
		
		var self = this;
        this.$super("soapbox_virtual");
		console.log("client connected");
		
		// user id
		var userName = Tundra.client.loginProperties.username;
		var userInfo = {"name" : userName, "id" : "", "avatarName" : ""};
		this.userInfo = userInfo;
		console.log(this.userInfo);

		//this.initUi(self);
		
		var onRenderFctsWithoutParam = [];
		var onRenderFctsWithParams = [];
		var listOfMeshObject = [];
		var listOfThreeGroup = [];
		var raycastData;		
		var isSpeechOn;
		var speakerInfo;
		var toVote = 1;
		var timerHandler;
		var ifSentSpeechInfo = false;
		var speechInfo = {"speaker": "", "topic": "", 
				"starttime":"", "password": "", "origin":""};
		
		var numOfUsersInTheVenue = 0; 	// except me
		this.numOfUsersInTheVenue = numOfUsersInTheVenue;
		var isUserInTheVenue = 0;
		this.isUserInTheVenue = isUserInTheVenue;	
		this.speakerInfo = speakerInfo;
		this.toVote = toVote;
		var coordinatorInfo = {"name" : "", "id" : ""};
		this.coordinatorInfo = coordinatorInfo;
		var avatarEntity;
		this.avatarEntity = avatarEntity;
		this.timerHandler = timerHandler;
		this.ifSentSpeechInfo = ifSentSpeechInfo;
		this.speechInfo = speechInfo;
		
		var ui = new Soapbox.Dashboard();
		ui.initUi(this);
		
		/* Tundra entities */
		var foothold = Tundra.scene.entityByName("soapbox_footbold");
		
		// video element
		var video= document.createElement('video');
		this.video = video;
		this.video = video;
		this.video.width = 320;
		this.video.height = 240;
		this.video.autoplay = true;
		this.video.loop = true;
		
		/***********configure with middleware******************/
		// middleware instance
		var virtual = new Virtual();
		this.virtual = virtual;	
		var audience = new Audience();
		this.audience = audience;
		
		virtual.connect(function(){
			virtual.register();
			// callback, when speech started in physical world
			virtual.onreceivespeechinfo = function (speech_info) {
				// behaviour for the coordinator - notify the meshmoon server about speech info from physical soapbox
				if(self.isCoordinatorMe()){
					console.log(speech_info);
					var speechInfoValues = {"name":speech_info.speaker, "title":speech_info.topic, 
					"description":"", "startTime":speech_info.starttime, "origin":"physical"};	// lefttime == startTime
					self.entity.exec(EntityAction.Server, _MSG_SPEECH_BEGIN_REQUEST, speechInfoValues);
				}
				
				//self.promptSpeechMsg(1);	// call at last
			} 
		});
		virtual.setup(video);
		
		//handled by middleware when user is logging out
		//onbeforeunload = function(){virtual.unregister();};
			
		/**************************************************/
		
		/* THREE */
		var videoTexture = new THREE.Texture(video);
		this.videoTexture = videoTexture;
		var threeMeshGroup = new THREE.Object3D();
		this.threeMeshGroup = threeMeshGroup;

		// textures
		tex = THREE.ImageUtils.loadTexture("./localAssets/like.jpg");
		texture_waiting = THREE.ImageUtils.loadTexture("./localAssets/waiting.jpg", function(error){
			console.log(this,"image not loaded, error");
		});
		this.texture_waiting = texture_waiting;
		
		////////////////////////////////////
		//* create objects for the scene *//
		////////////////////////////////////
		
		var url = []; 
		var objPosition = [];
		var geo = [];
		// create screen object
		// texture init with waiting mode 
		var screenMesh = this.createCubeObj(this.videoTexture, "video_screen", POSITION_SCREEN_DEFAULT, geo);
		this.screenMesh = screenMesh;
		// create like button object
		//url = './localAssets/ic_sentiment_satisfied_black_24dp/web/ic_sentiment_satisfied_black_24dp_2x.jpg'; 		
		//var btnMesh = this.createBtnObj(url, "likeBtn", POSITION_LIKE_DEFAULT, GEO_BUTTON_DEFAULT); // create likeBtn
		// create dislike button object
		//url = './localAssets/ic_sentiment_dissatisfied_black_24dp/web/ic_sentiment_dissatisfied_black_24dp_2x.jpg'; 	
		//var btnMesh2 = this.createBtnObj(url, "disLikeBtn", POSITION_DISLIKE_DEFAULT, GEO_BUTTON_DEFAULT); // disLikeBtn
		// create report button object
		url = './localAssets/ic_sentiment_very_dissatisfied_black_24dp/web/ic_sentiment_very_dissatisfied_black_24dp_2x.jpg';
		var reportBtn = this.createBtnObj(url, "reportBtn", POSITION_REPORT_DEFAULT,GEO_BUTTON_DEFAULT)
		// to change texture's emissive attribute
		//var hexOfBtn1 = this.getHexValue(btnMesh);
		//var hexOfBtn2 = this.getHexValue(btnMesh2);
 
		// add objects to the three.scene
		Tundra.renderer.scene.add(this.threeMeshGroup);
		console.log(Tundra.renderer);
		console.log(Tundra);
		////* Listeners *////
		// entity event listeners
        this.entity.onEntityAction(this, this.onEntityAction);
		foothold.onEntityAction(this, this.onEntityAction);

		// mouse event listeners
		var mouseEvents = Tundra.input.onMouseEvent(this, this.onMouseEvent); // function(context, callback) 
		Tundra.events.subscribe(_MSG_MOUSE_PRESS, this, this.onMousePress); 
		Tundra.events.subscribe(_MSG_MOUSE_RELEASE, this, this.onMouseRelease);
		Tundra.events.subscribe(_MSG_MOUSE_HOVER, this, this.onMouseHoverObj);

        // introduce this user to the server
        this.entity.exec(EntityAction.Server, _MSG_INITIATION);
		
		/**************get video stream*******************/
		//https://github.com/jeromeetienne/threex.videotexture/blob/master/examples/videotexture.html

		/* functions to be rendered in a loop */		
		onRenderFctsWithoutParam.push(function(){
			self.videoTextureUpdate(); 	
		});
		onRenderFctsWithoutParam.push(function(){
			self.raycastData = self.rayCast();							
		});
		
		// define whether user is near the screen 
		onRenderFctsWithoutParam.push(function(){
			try{
				//console.log(Tundra.scene.entityByName("Avatar2").placeable.transform.pos.z);
				//self.sendToServer();
				self.dynamicVolumeObserver(self.avatarEntity);
				self.userJoinedVenue(self.avatarEntity);
				//console.log(self.video.volume);
			}catch(e){
				console.log("userInfo is not initiated yet or not given at all");
			}
		});
	
		///////////////////////////////////////////////////////
		
		listOfMeshObject = this.getListOfMeshObj();
		this.listOfMeshObject = listOfMeshObject;
		
		// get soapbox obj from meshmoon asset
		// add into threejs scene 
		function getSoapboxObj(element, index, array) {		
		  while (element.name == SOAPBOX_NAME) {
			  return element;
		  }
		}

		var soapboxObj = listOfMeshObject.find(getSoapboxObj);
		this.soapboxObj = soapboxObj;
		console.log(soapboxObj);

		function getThumbUpObj(element, index, array) {		
		  while (element.name == THUMB_UP_NAME) {
			  return element;
		  }
		}

		var thumbUpObj = listOfMeshObject.find(getThumbUpObj);
		this.thumbUpObj = thumbUpObj;
		this.thumbUpObj.name = 'thumb_up';
		THUMB_UP_NAME = 'thumb_up';
		console.log(thumbUpObj);


		function getThumbDownObj(element, index, array) {		
		  while (element.name == THUMB_DOWN_NAME) {
			  return element;
		  }
		}

		var thumbDownObj = listOfMeshObject.find(getThumbDownObj);
		this.thumbDownObj = thumbDownObj;
		this.thumbDownObj.name = 'thumb_down';
		THUMB_DOWN_NAME = 'thumb_down';
		console.log(thumbDownObj);

		// handle irregular fashion in shutdown of the application
		window.onbeforeunload = function(event) {
			if(self.isSpeakerMe()){
				event.returnValue = "Write something clever here..";
				self.virtual.stop();
			}
		};

/* 		listOfThreeGroup = this.getListOfObj3D();
		this.listOfThreeGroup = listOfThreeGroup; */
		
		console.log(Tundra.renderer.renderer.domElement.toDataURL());
		 var ws = new WebSocket("ws://localhost:8889/");
		    var frame = 0;
		    var isOpen = false;
		    ws.onopen = function(e) {
		        console.log('opening');
		        isOpen = true;
		    };
		    ws.onclose = function(e) {
		        console.log('closing');
		        console.log(e);
		        isOpen = false;
		    };
		    ws.onerror = function(e) {
		        console.log('error');
		        console.log(e);
		    }
		console.log(ws);	
		// loop for video render etc.
		// im thinking this function title is not predetermined
		requestAnimationFrame(function animation()
		{
			var len = onRenderFctsWithoutParam.length;
			if(len !== 0)
			{
				onRenderFctsWithoutParam.forEach(function(onRenderFctsWithoutParam)
				{
					onRenderFctsWithoutParam();
				});
			}
			if(len !== 0)
			{
				onRenderFctsWithParams.forEach(function(onRenderFctsWithParams)
				{
					if(onRenderFctsWithParams.length === 1)
						onRenderFctsWithParams();
					else if(onRenderFctsWithParams.length === 2)
						onRenderFctsWithParams();
					else if(onRenderFctsWithParams.length === 3)
						onRenderFctsWithParams();
				});
			}
			requestAnimationFrame(animation);
		})
		
    },
	////////////////////////////////////////////
	//*  this.methods in alphabetical order */// 
	////////////////////////////////////////////
	
	addNewComment : function(text, name, id){		
		var commentInnerDiv = document.createElement("div");  // comment holder div
		var comment = document.createElement("b"); // comment text		
		commentInnerDiv.id = "commentInnerDiv";
		comment.id = "comment";
		
		if(typeof id === 'undefined'){/*physical user*/}
		else{/*virtual user*/}
		
		$(commentInnerDiv).css({
			position : "relative",
			width : "100%",
			height : "40px",		
		});		
		$(comment).css({
			position : "relative",
			width : "100%",
			height : "30px",
			color : "black",
			//font-weight : "bold";				
		});				
		comment.innerHTML = name + ": " + text;
		
		/* //mouse hover, not used 			
		$(self.userIdInner).mouseover(function(){
			$(self.userIdInner).css("background-color", "red");
		});
		$(self.userIdInner).mouseout(function(){
			$(self.userIdInner).css("background-color", "white");
		});	 */	
		
		var parent = this.dashboard.children["commentDiv"];
		parent.appendChild(commentInnerDiv);
		commentInnerDiv.appendChild(comment);

	},
	
	// open up url for speech registration when virtual user try to do so 
	callRegistration : function(url){
		var _url = url
		_url.replace("watch?v=", "v/");
		window.open(_url, "new");
	},
	
	// change size of the screen accordingly to the number of users in the venue
	changeScreenSize : function(numOfUsers){
		if(numOfUsers >= 1){
			this.screenMesh.scale.set(0.01, 4, 4); // will be pre-defined
			this.screenMesh.position.y = 12.50;
		}else if(numOfUsers == 0){
			this.screenMesh.scale.set(GEO_SCREEN_DEFAULT.v1, GEO_SCREEN_DEFAULT.v2, GEO_SCREEN_DEFAULT.v3);		// will be pre-defined
			this.screenMesh.position.y = POSITION_SCREEN_DEFAULT.y;
		}
		console.log("screen size change " + numOfUsers);
	},
	
	createBtnObj : function(url, name, initPosition, geo){

		if(!url){
			console.log("error, no url of texture for the obj");
			return;
		}else if(typeof name == 'undefined'){
			console.log("this obj has given no name");
			var name = '';
		}else if(typeof initPosition == 'undefined'){
			console.log("warning, initial coordinate has not given, will be set as default value: 55, 9, -44");
			var initPosition = [];
		}else if(typeof geo == 'undefined'){
			console.log("warning, initial geometry value has not given, will be set as default value: 2, 2, 2");
			var geo = [];
		}
		
		var btnTexture = THREE.ImageUtils.loadTexture(url, function(error){
			console.log(this,"image not loaded, error");
		});

		var btnMaterial = new THREE.MeshLambertMaterial({map: btnTexture});
		var btnGeometry = new THREE.BoxGeometry(geo.v1 ? geo.v1 : GEO_SCREEN_DEFAULT.v1
		, geo.v2 ? geo.v2 : GEO_SCREEN_DEFAULT.v2
		, geo.v3 ? geo.v3 : GEO_SCREEN_DEFAULT.v3);
		var btnMesh = new THREE.Mesh( btnGeometry, btnMaterial );
		
		btnMesh.name = name;
		btnMesh.position.x = initPosition.x ? initPosition.x : 55;
		btnMesh.position.y = initPosition.y ? initPosition.y : 9;
		btnMesh.position.z = initPosition.z ? initPosition.z : -44;
		console.log(btnMesh);
		this.threeMeshGroup.add(btnMesh);
		
		return btnMesh;

	},
	
	createCubeObj : function(texture, name, initPosition, geo){
		if(!texture){
			console.log("error, no url of texture for the obj");
			return false;
		}else if(typeof texture == 'string'){
			var texture = THREE.ImageUtils.loadTexture(texture, function(error){
				console.log(this,"image not loaded, error");
			});
		}	
		if(typeof name == 'undefined'){
			console.log("this obj has given no name");
			var name = "";
		}else if(typeof initPosition == 'undefined'){
			console.log("warning, initial coordinate has not given, will be set as default value: 55, 9, -44");
			var initPosition = [];
		}else if(typeof geo == 'undefined'){
			console.log("warning, initial geometry value has not given, will be set as default value: 2, 2, 2");
			var geo = [];
		}
		var geometry = new THREE.BoxGeometry(geo[0] ? geo[0] : 2, geo[1] ? geo[1] : 2, geo[2] ? geo[2] : 2);
		console.log(texture);
		var material = new THREE.MeshLambertMaterial({ map: texture});
		var cubeMesh = new THREE.Mesh(geometry, material);	
		
		cubeMesh.name = name;
		cubeMesh.position.x = initPosition.x ? initPosition.x : 55;
		cubeMesh.position.y = initPosition.y ? initPosition.y : 9;
		cubeMesh.position.z = initPosition.z ? initPosition.z : -44;

		this.threeMeshGroup.add(cubeMesh);
		
		return cubeMesh;
	},
	
	dynamicVolumeChanger : function(val){
		if(val>29.6){
			if(USER_VOLUME_ZONE===0)
				return;
			this.video.volume = 1;
			USER_VOLUME_ZONE = 0;
			return;			
		}	// this can be any float ex) 9.x
		var zoneVal = Math.floor(val/VOLUME_CHANGE_VALUE);
		//console.log("changer: "+ zoneVal);
		switch(parseInt(zoneVal)){
			case 9:
				if(USER_VOLUME_ZONE===1)
					return;
				this.video.volume = 0.9;
				USER_VOLUME_ZONE = 1;
				break;
			case 8:
				if(USER_VOLUME_ZONE===2)
					return;
				this.video.volume = 0.8;
				USER_VOLUME_ZONE = 2;
				break;
			case 7:
				if(USER_VOLUME_ZONE===3)
					return;
				this.video.volume = 0.7;
				USER_VOLUME_ZONE = 3;
				break;
			case 6:
				if(USER_VOLUME_ZONE===4)
					return;
				this.video.volume = 0.6;
				USER_VOLUME_ZONE = 4;
				break;
			case 5:
				if(USER_VOLUME_ZONE===5)
					return;
				this.video.volume = 0.5;
				USER_VOLUME_ZONE = 5;
				break;
			case 4:
				if(USER_VOLUME_ZONE===6)
					return;
				this.video.volume = 0.4;
				USER_VOLUME_ZONE = 6;
				break;
			case 3:
				if(USER_VOLUME_ZONE===7)
					return;
				this.video.volume = 0.3;
				USER_VOLUME_ZONE = 7;
				break;
			case 2:
				if(USER_VOLUME_ZONE===8)
					return;
				this.video.volume = 0.2;
				USER_VOLUME_ZONE = 8;
				break;
			case 1:
				if(USER_VOLUME_ZONE===9)
					return;
				this.video.volume = 0.1;
				USER_VOLUME_ZONE = 9;
				break;
			case 0:
				if(USER_VOLUME_ZONE===0)
					return;
				this.video.volume = 0;
				USER_VOLUME_ZONE = 0;
				break;
			default:
				break;
		}
	},
	
	dynamicVolumeObserver : function(ent){
		if(!this.isSpeechOn)
			return false;
		if(this.isSpeakerMe())
			return false;
		if(typeof ent === 'undefined')
			return false;
		
		if((SET_AREA_FOR_MIN_VOLUME_FROM.x>x && x>SET_AREA_FOR_MIN_VOLUME_TO.x) &&
		(SET_AREA_FOR_MIN_VOLUME_FROM.z>z && z>SET_AREA_FOR_MIN_VOLUME_TO.z)){
			console.log("stop shitting");
			return false;
		}
		var x = ent.placeable.transform.pos.x;
		var y =	ent.placeable.transform.pos.y;
		var z = ent.placeable.transform.pos.z;
		/** volume control algorithm **/
		//////////////////////////////////////
		//			|	   B	 |	  C	 	//
		//	  A	(volume in control|zone)	//
		//			|			 |			//
		//----------//////////////----------//
		//			//	active	//			//
		//		D	//	speech	//	 E		//
		//			//	zone	//			//
		//----------//////////////----------//
		//			|			 |			//
		//		F	|		G	 |		H	//
		//			|			 |			//
		//			|			 |			//
		//////////////////////////////////////
		
		// covers A,B,C Zones 
		if(SET_AREA_FOR_SPEECH_FROM.x>x && x>=SET_AREA_FOR_MIN_VOLUME_FROM.x){	
			// covers B Zone
			if(SET_AREA_FOR_SPEECH_FROM.z<z && z<SET_AREA_FOR_SPEECH_TO.z){
				this.dynamicVolumeChanger(x-SET_AREA_FOR_MIN_VOLUME_FROM.x);
				return;
			// covers A zone
			}else if(SET_AREA_FOR_SPEECH_TO.z<z && z<SET_AREA_FOR_MIN_VOLUME_TO.z){
				if(SET_AREA_FOR_SPEECH_FROM.x-x>z-SET_AREA_FOR_SPEECH_TO.z){
					this.dynamicVolumeChanger(x-SET_AREA_FOR_MIN_VOLUME_FROM.x);
					return;
				}else{
					this.dynamicVolumeChanger(SET_AREA_FOR_MIN_VOLUME_TO.z-z);
					return;
				}
			// covers C zone
			}else if(SET_AREA_FOR_SPEECH_FROM.z>z && z>SET_AREA_FOR_MIN_VOLUME_FROM.z){
				if(SET_AREA_FOR_SPEECH_FROM.x-x>SET_AREA_FOR_SPEECH_FROM.z-z){
					this.dynamicVolumeChanger(x-SET_AREA_FOR_MIN_VOLUME_FROM.x);
					return;
				}else{
					this.dynamicVolumeChanger(z-SET_AREA_FOR_MIN_VOLUME_FROM.z);
					return;
				}
			}
		// covers F,G,H Zones 
		}else if(SET_AREA_FOR_SPEECH_TO.x<x && x<SET_AREA_FOR_MIN_VOLUME_TO.x){
			// covers G Zone
			if(SET_AREA_FOR_SPEECH_FROM.z<z && z<SET_AREA_FOR_SPEECH_TO.z){
				this.dynamicVolumeChanger(SET_AREA_FOR_MIN_VOLUME_TO.x-x);
				return;
			// covers F Zone
			}else if(SET_AREA_FOR_SPEECH_TO.z<z && z<SET_AREA_FOR_MIN_VOLUME_TO.z){
				if(x-SET_AREA_FOR_SPEECH_TO.x>z-SET_AREA_FOR_SPEECH_TO.z){
					this.dynamicVolumeChanger(SET_AREA_FOR_MIN_VOLUME_TO.x-x);
					return;
				}else{
					this.dynamicVolumeChanger(SET_AREA_FOR_MIN_VOLUME_TO.z-z);
					return;
				}
				// covers H Zone
			}else if(SET_AREA_FOR_SPEECH_FROM.z>z && z>SET_AREA_FOR_MIN_VOLUME_FROM.z){
				if(x-SET_AREA_FOR_SPEECH_TO.x>SET_AREA_FOR_SPEECH_FROM.z-z){
					this.dynamicVolumeChanger(SET_AREA_FOR_MIN_VOLUME_TO.x-x);
					return;
				}else{
					this.dynamicVolumeChanger(z-SET_AREA_FOR_MIN_VOLUME_FROM.z);
					return;
				}
			}
			// covers D Zone
		}else if(z>SET_AREA_FOR_SPEECH_TO.z && z<SET_AREA_FOR_MIN_VOLUME_TO.z
		&& x<SET_AREA_FOR_MIN_VOLUME_TO.x && x>SET_AREA_FOR_MIN_VOLUME_FROM.x){
			this.dynamicVolumeChanger(SET_AREA_FOR_MIN_VOLUME_TO.z-z);
			return;
			// covers E Zone
		}else if(z<SET_AREA_FOR_SPEECH_FROM.z && z>SET_AREA_FOR_MIN_VOLUME_FROM.z
		&& x<SET_AREA_FOR_MIN_VOLUME_TO.x && x>SET_AREA_FOR_MIN_VOLUME_FROM.x){
			this.dynamicVolumeChanger(z-SET_AREA_FOR_MIN_VOLUME_FROM.z);
			return;
		}
		return false;
	},
	
	isCoordinatorMe : function(){
		if(typeof this.coordinatorInfo === 'undefined' | this.coordinatorInfo.id === "")
			return false;
		
		if(this.userInfo.id === this.coordinatorInfo.id){
			return true;
		}
		return false;
	},
	
	isSpeakerMe : function(){
		if(typeof this.userInfo == 'undefined' | typeof this.speakerInfo == 'undefined'){
			//console.log("User information or current Speaker information is not known to the system");
			return false;
		}
		
		var userId = this.userInfo.id;
		var speakerId = this.speakerInfo.speakerInfo[0].generalInfo.id;
		
		if(userId == speakerId){
			//console.log("this user is the speaker");
			return true;
		}else{
			//console.log("this user is not the speaker");
			return false;
		}
	},

	getHexValue : function(obj){
		return obj.material.emissive.getHex();
	},
	
	getListOfMeshObj : function(){
		var arr = [];
		Tundra.renderer.scene.traverse(function(object)
		{
			if(object instanceof THREE.Mesh)
				arr.push(object);
		}, function(error)
		{
			console.log("getting list of object failed");
		});
		console.log(arr);
		if(arr.length !== 0)
			return arr;
		else
			return false;
	},
	
	getListOfObj3D : function(){
		var arr = [];
		Tundra.renderer.scene.traverse(function(object)
		{
			if(object instanceof THREE.Object3D)
				arr.push(object);
		}, function(error)
		{
			console.log("getting list of object failed");
		});
		if(arr.length !== 0)
			return arr;
		else
			return false;
		
	},
	
	onClickTeleport : function(){		
		this.entity.exec(EntityAction.Server, _MSG_USER_TELEPORT_REQ, this.userInfo.avatarName);
	},

    onEntityAction : function(entityAction){
		
        if(entityAction.name === _MSG_INITIATION)
		{
			// CLIENT INIT
            this.log.info("Server messaged it is ready");
			
			// user init with init params received from the server
			// speech state, user id determined by server
			this.initParams(JSON.parse(entityAction.parameters[0]));
        }
		else if(entityAction.name === _MSG_BROADCAST)
		{ 
		// entityAction.parameters[0] -> text
		// entityAction.parameters[1] -> user name
		// entityAction.parameters[2] -> user id or null if it's from physical world
			this.addNewComment(entityAction.parameters[0], entityAction.parameters[1], entityAction.parameters[2]);
		}
		// entityAction.parameters[0] -> entity name
		// entityAction.parameters[1] -> entity id
		else if(entityAction.name === _MSG_SPEECH_BEGIN)
        {
        	this.ifSentSpeechInfo = true;			// speech info is submitted and accepted
			this.speakerInfo = JSON.parse(entityAction.parameters[0]);
			if(this.isSpeakerMe()){
				//Example: "21/02/2016 12:05"
				// set speech info to send to the middleware
				this.speechInfo.speaker = this.userInfo.name;
				this.speechInfo.topic = document.getElementById("titleInput").value;
				this.speechInfo.starttime = current_time_string();
				this.speechInfo.password = "null";
				console.log(this.speechInfo);
				this.setVideoFeed(this, this.video);
			}
			this.setSpeechBegin(entityAction.parameters[0]);
        }
		else if(entityAction.name === _MSG_SPEECH_BEGIN_REQUEST)
		{
			// send request to the speaker to fill the speech info
			//var speechTitle = this.setSpeechInfo();
			document.getElementById("descriptionInput").value = "Speech description";
			document.getElementById("titleInput").value = "Title";
			//$("descriptionInput").value = "Speech description";
			//$("titleInput").value = "Title";
			$("infoDash").show();

			this.ifSentSpeechInfo = false;
			TIME_LIMIT = TIME_LIMIT_VALUE;
			this.setTimer(this);		// timer is working wrong 8/3/2016
			//if(speechTitle != false){
				// param : speech title or in the future, this could be a json format of data set
			//	this.entity.exec(EntityAction.Server, _MSG_SPEECH_BEGIN_REQUEST, speechTitle);  
			//}			
		}
		else if(entityAction.name === _MSG_SPEECH_END)
        {
			// name, id, entity name, entity id
			this.setSpeechEnd(entityAction.parameters[0]);
        }
		else if(entityAction.name === _MSG_SPEECH_END_REQUEST)
		{
			this.promptSpeechMsg(2); // confirm if speaker wants to end the speech
		}
		// find user request
		else if(entityAction.name === _MSG_FOUND_USER)
        {
        }
		else if(entityAction.name === _MSG_NOT_FOUND_USER)
        {
			
        }
		// user enter/leave the speech area
		else if(entityAction.name === _MSG_USER_JOINED_VENUE)
		{
			this.numOfUsersInTheVenue = entityAction.parameters[0];
			this.changeScreenSize(entityAction.parameters[0]);
		}
		else if(entityAction.name === _MSG_USER_LEFT_VENUE)
		{
			this.numOfUsersInTheVenue = entityAction.parameters[0];
			this.changeScreenSize(entityAction.parameters[0]);
		}			
		// raycast tundra objects
		else if(entityAction.name === _MSG_RAYCAST)
		{
			//TODO

			Tundra.events.send(_MSG_MOUSE_HOVER);
			//console.log(this.raycastData[0].object.name);
			
		}
		else if(entityAction.name === _MSG_VOTE)
		{
			this.refreshVote(entityAction.parameters[0], entityAction.parameters[1]); // like, dislike
		}
		else if(entityAction.name === _MSG_SELECT_COORDINATOR)
		{
			console.log("coordinator info: "+entityAction.parameters[0]);
			this.coordinatorInfo = JSON.parse(entityAction.parameters[0]);
			// important!!
			// init callbacks of middleware to sync all the data
			if(this.isCoordinatorMe()){
				this.initMiddlewareCallbacks(this);
			}
		}
    },
	
	onMouseEvent : function(event){
		// set live coordinate of the mouse
		var x;
		var y;
		this.x = event.x;
		this.y = event.y;
		
		if(event.type === "press"){
			Tundra.events.send(_MSG_MOUSE_PRESS, event);
		}
		if(event.type === "release"){
			Tundra.events.send(_MSG_MOUSE_RELEASE, event);
		}
	},
	
	onMouseHoverObj : function(){
		var hoverObj = this.raycastData;
			
		if(hoverObj == '' | typeof hoverObj == 'undefined'){return;}
		else{
			var objLen = hoverObj.length;
			for(var i=0; i<objLen; i++){
				var obj = hoverObj[i].object; // get name of obj in which current mouse is upon
				
				// find vote blocks
				if(this.toVote & this.isSpeechOn){
					if(obj.name == THUMB_UP_NAME | obj.name == THUMB_DOWN_NAME | obj.name == 'reportBtn'){
						if(obj.name == THUMB_UP_NAME){
							// 0 otherwise use getHexValue() to store inital hexvalue of the obj
							this.setHexValue(obj, HEX_LIKE, this.thumbDownObj, 0); 
							return;
						}else if(obj.name == THUMB_DOWN_NAME){
							this.setHexValue(obj, HEX_DISLIKE, this.thumbUpObj, 0);
							return;
						}else if(obj.name == 'reportBtn'){
							this.setHexValue(obj, HEX_REPORT, this.thumbUpObj, 0);
							return;
						}
					}else{
						// set back the colour 
						this.setHexValue(this.thumbUpObj, 0);
						//this.setHexValueBack(THUMB_UP_NAME, 0);
						this.setHexValue(this.thumbDownObj, 0);
						//this.setHexValueBack("disLikeBtn", 0);
						this.setHexValueBack("reportBtn", 0);
					}
				}else{ 
				// find vote blocks, will be made a method in a near future		
				}				
				// find soapbox
				if(obj.name == SOAPBOX_NAME){
					this.setHexValue(obj, 996633);
					return;
				}else{  // when mouse leaves soapbox
					if(typeof this.soapboxObj == 'undefined'){
						return;
					}else{
						// also need to be optimized
						this.setHexValue(this.soapboxObj, 0); // for some reason setHexValueBack() doesn't work
						//this.setHexValueBack(this.soapbox_obj, 0);  // set back colour of soapbox to normal
					}
				}
				
				// find other obj if needed
			}
		}	
	},
	//// not working for some reason
/* 	onMouseHoverBtn : function(obj){
		// find mouse hover on voting blocks
		if(obj.name == 'likeBtn' | obj.name == 'disLikeBtn'){
			if(obj.name == 'likeBtn'){
				console.log("im on likeBtn");
				this.setHexValue(obj, 0x00ff00, "disLikeBtn", this.hexOfBtn2);
				return;
			}else if(obj.name == 'disLikeBtn'){
				console.log("im on disLikeBtn");
				this.setHexValue(obj, 0xff0000, "likeBtn", this.hexOfBtn1);
				return;
			}
		}else{
			// set back the colour 
			this.setHexValueBack("likeBtn", this.hexOfBtn1);
			this.setHexValueBack("disLikeBtn", this.hexOfBtn2);
		}		
	}, */
	
	onMousePress : function(event){		
		var objTargetted;	
		console.log(event.type)
		console.log(event);
		objTargetted = this.rayCast();
		
		if(objTargetted)
		{
			var objLen = objTargetted.length;
			for(var i=0; i<objLen; i++)
			{
				console.log(objTargetted[i].object.name);
				var obj = objTargetted[i].object;
				// user votes
				this.onMousePressBtn(obj);
				this.onMousePressSoapbox(obj)
			}
		}
		//TODO		
	},
	
	onMousePressBtn : function(obj){
		// recognize buttons when only a speech is on 
		if(this.toVote & this.isSpeechOn){
			if(obj.name == THUMB_UP_NAME | obj.name == THUMB_DOWN_NAME | obj.name == 'reportBtn'){
				if(obj.name == THUMB_UP_NAME){
					// vote like
					this.onVote(1);
					this.virtual.like();
					this.setHexValue(this.thumbUpObj, 0);		
					//this.setHexValueBack(THUMB_UP_NAME, 0);					
				}else if(obj.name == THUMB_DOWN_NAME){
					// vote dislike
					this.onVote(0);
					this.virtual.dislike();		
					this.setHexValue(this.thumbDownObj, 0);
					//this.setHexValueBack("disLikeBtn", 0);
				}else if(obj.name == 'reportBtn'){
					this.onVote(-1);
					this.virtual.report();		
					this.setHexValueBack("reportBtn", 0);
				}
			}
		}		
	},
	
	onMousePressSoapbox : function(obj){
		// when user press the soapbox
		if(obj.name == SOAPBOX_NAME){  
			console.log("soapbox clicked");
			this.callRegistration(PATH_TO_REGISTRATION);
		}
		
	},
	
	// user vote on the speaker
	onVote : function(vote){
		var voteInfo = {"vote":vote, "origin":"virtual"};
		this.toVote = 0;

		if(vote==1){
			console.log("you liked the speech");
			this.entity.exec(EntityAction.Server, _MSG_VOTE, voteInfo);
			
		}else if(vote<0){
			console.log("you reported this speech as containing inappropriate contents");
			this.entity.exec(EntityAction.Server, _MSG_VOTE, voteInfo);
		}else{
			console.log("you disliked the speech");
			this.entity.exec(EntityAction.Server, _MSG_VOTE, voteInfo);
		}
			
	},
		
	onMouseRelease : function(event){	
		console.log(event.type)
		// TODO 
	},
	
	promptSpeechMsg : function(action){
		if(action == 1){ // send msg to all users that speech has started
			if (confirm("A speech is about to begin! Click 'ok' to teleport to the venue") == true) {
				this.onClickTeleport();
				this.video.volume = 1;
			} else {}
			// action = 2 -> speech trigger and end related action
		}else if(action == 2){
			console.log("server noticed speaker tries to leave the soapbox");
			var ans = this.prompMsg("Would you like to end the speech?");
			if (ans == true) {
				// speaker agrees to end the speech
				this.entity.exec(EntityAction.Server, _MSG_SPEECH_END_REQUEST, 
					{"signal":1, "origin":"virtual"});
				
			} else if (ans == false) {
				// end attempt was a mistake 
				this.entity.exec(EntityAction.Server, _MSG_SPEECH_END_REQUEST,
					{"signal":0, "origin":"virtual"});
			}
		}
	
	},
	
	prompMsg : function(text){
		return confirm(text);
	},
	
	rayCast : function(){	
	
		var rayCastEnt = Tundra.renderer.raycast();
		var threeRaycaster = Tundra.renderer.raycaster;
		var obj = threeRaycaster.intersectObjects(this.listOfMeshObject);
		if(obj)
		{
			this.entity.exec(EntityAction.Local, _MSG_RAYCAST);
			return obj;
		}
		
		return false;
	},
	
	refreshVote : function(like, dislike){

		if(typeof like == 'undefined'){
			like = 0;
		}else if(typeof dislike == 'undefined'){
			dislike = 0;
		}
		
		// refresh vote state
		this.dashboard.children["votePanel"].children["voteType"].innerHTML = "like: " + like + "  " + "dislike: " + dislike;
	},	
	
	removeVotePanel : function(){
		// empty the vote panel
		this.dashboard.children["votePanel"].children["voteType"].innerHTML = ""; 
	},
	
	setDynamicObjScale : function(obj, scale){
		var geoX = scale.x;
		var geoY = scale.y;
		var geoZ = scale.z;
		
	},
	
	setHexValue : function(obj, toHexValue, nearObj, toHexValueSec){	
		if(typeof nearObj == "undefined"){
			try{
				obj.material.emissive.setHex(toHexValue);	
			}catch(err){
				console.log("no emissive value on this object");
			}
		}else if(typeof nearObj == "string"){
			obj.material.emissive.setHex(toHexValue);
			var secondObj = this.threeMeshGroup.getObjectByName(nearObj);
			secondObj.material.emissive.setHex(toHexValueSec);
		}else{
			obj.material.emissive.setHex(toHexValue);
			nearObj.material.emissive.setHex(toHexValueSec);
		}
	},
		
	setHexValueBack : function(obj, toHexValue){	
		if(typeof obj == 'undefined'){
			return false; 
		}else if(typeof obj == "string"){
			var obj = this.threeMeshGroup.getObjectByName(obj);
			obj.material.emissive.setHex(toHexValue);
		}else{
			obj.material.emissive.setHex(toHexValue);
		}
	},

	setSpeakerInfoDefault : function(){
		this.speakerInfo.speakerInfo[0].generalInfo.name = "";
		this.speakerInfo.speakerInfo[0].generalInfo.id = "";
		this.speakerInfo.speakerInfo[1].entityInfo.name = "";
		this.speakerInfo.speakerInfo[1].entityInfo.id = "";
	},
		
	setSpeechBegin : function(infoData){	
		this.isSpeechOn = 1; 	// speech is off state
		this.toVote = 1;		// right to vote refreshed
		this.speakerInfo = JSON.parse(infoData);
		
		console.log("speech begins by: " + this.speakerInfo.speakerInfo[0].generalInfo.name);
		// speaker himself should not have a teleport button
		var obj = this.threeMeshGroup.getObjectByName("video_screen");
		console.log(obj);
		// set video texture 
		this.screenMesh.material.map = this.videoTexture;
		
		if(this.isSpeakerMe()){
			this.dashboard.children["teleportBtn"].hidden = true;
			//If it wants to start a speech right now
			console.log(this.video);
			$("infoDash").hide();			
		}else{
			// this user is not the speaker 
			this.dashboard.children["teleportBtn"].hidden = false;
			//this.promptSpeechMsg(1);	// notify users that speech will soon begin
		}
		$("dashboard").show();
	},
	
	setSpeechEnd : function(infoData){
		this.isSpeechOn = 0; // speech is off state
		this.toVote = 1; // right to vote refreshed
		this.speakerInfo = JSON.parse(infoData);		
		console.log("speech ends by: " + this.speakerInfo.speakerInfo[0].generalInfo.name);
		this.removeVotePanel();
		
		// stop soapbox
		if(this.isSpeakerMe()){
			this.virtual.stop();
		}
		$("dashboard").hide();
		this.video.pause();
		this.video.volume = SET_VOLUME_VALUE;
		this.screenMesh.material.map = this.texture_waiting;
		this.setSpeakerInfoDefault();
		this.setSpeechInfoDefault();
	},
	
	setSpeechInfo : function(){	
		var title = prompt("Enter a title for speech");
    
		if (title != null) {
			return title;
		}else{
			confirm("Enter a title to begin the speech");
			return false;
		}
	},

	setSpeechInfoDefault : function(){
		this.speechInfo.speaker = "";
		this.speechInfo.topic = "";
		this.speechInfo.starttime = "";
		this.speechInfo.password = "";
		this.speechInfo.origin = "";
	},
	
	setTimer : function(context){		
		this.counter.innerHTML="Time remaining: "+TIME_LIMIT--;
		console.log(TIME_LIMIT);
		if(TIME_LIMIT >= 0){
			this.timerHandler = setTimeout(function(){ context.timerHandler = context.setTimer(context) }, 1000);
		}else if(this.ifSentSpeechInfo){
			clearTimeout(this.timerHandler);
			this.entity.exec(EntityAction.Server, _MSG_RELEASE_PENDING, this.userInfo.avatarName);
			$("infoDash").hide();			
			this.counter.innerHTML="";
		}else{
			this.counter.innerHTML="";
			$("infoDash").hide();
			this.entity.exec(EntityAction.Server, _MSG_USER_TELEPORT_REQ, this.userInfo.avatarName);
			this.entity.exec(EntityAction.Server, _MSG_RELEASE_PENDING, this.userInfo.avatarName);
		}
		console.log(this.ifSentSpeechInfo);
	},
	
	setLoop : function(context){
		setTimeout(function(){
			
			
			context.setLoop();
		}, 1000);
	},
	
	setVideoFeed : function(context, video){
		//chrome
		if(navigator.webkitGetUserMedia){
			console.log("passing navigator");
			navigator.webkitGetUserMedia(
			{
				video:true,
				audio:true
			},
			function(blob)
			{
				console.log("passing blob");
				video.src = window.URL.createObjectURL(blob);
				if(context.isSpeakerMe()){
					video.volume = SET_VOLUME_VALUE-1;		// set 0 volume for speaker himself
				}
				// speech started
				context.virtual.start(blob, context.speechInfo);
				console.log("i am the speaker");
				console.log(video);
				video.play();
			},
			function(error)
			{
				// this user has no camera working, request abortion of the speech
				context.entity.exec(EntityAction.Server, _MSG_ABORT_SPEECH, 1);
				alert('you have got no WebRTC webcam');
			});
			
		// firefox
		}else if(navigator.mozGetUserMedia){
			navigator.mozGetUserMedia({
				video:true,
				audio:true
			},
			function(blob)
			{
				video.src = window.URL.createObjectURL(blob);
				if(context.isSpeakerMe()){
					video.volume = SET_VOLUME_VALUE-1;		// set 0 volume for speaker himself
				}
				// speech started
				//var startTime = current_time_string(); 		//Example: "21/02/2016 12:05"
				//var speech_info = {"name": "Jilin", "topic": "New speech", "startTime": startTime, "password": "abcdefg123"};
				//context.virtual.start(blob, self.speechInfo); 
				console.log("i am the speaker");
				console.log(video);
				video.play();
			},
			function(error)
			{
				alert('you have got no WebRTC webcam');
			});
		}else{
			console.log("video streaming failed");
		}
	},
		
	// define whether user is near the screen
	userJoinedVenue : function(ent){
		if(typeof ent === 'undefined')
			return false;

		var x = ent.placeable.transform.pos.x;
		var y =	ent.placeable.transform.pos.y;
		var z = ent.placeable.transform.pos.z;

		if((SET_AREA_FOR_SPEECH_FROM.x < x&x < SET_AREA_FOR_SPEECH_TO.x)&
		(SET_AREA_FOR_SPEECH_FROM.z < z&z < SET_AREA_FOR_SPEECH_TO.z)){
			if(this.isUserInTheVenue == 0){
				this.isUserInTheVenue = 1;
				this.entity.exec(EntityAction.Server, _MSG_USER_JOINED_VENUE, this.userInfo.id);
				console.log("you are in !!!!!");
				//ent.dispatchEvent(test);
			}
		}else{
			if(this.isUserInTheVenue == 1){
				this.isUserInTheVenue = 0;
				this.entity.exec(EntityAction.Server, _MSG_USER_LEFT_VENUE, this.userInfo.id);
				console.log("you are out !!!!!");
			}
		}
		//console.log(ent.placeable.transform.pos.x + " " + ent.placeable.transform.pos.y + " " + ent.placeable.transform.pos.z);
		
	},

	videoTextureUpdate : function(){
		try{
			if(this.video.readyState !== this.video.HAVE_ENOUGH_DATA)
				return;
			this.videoTexture.needsUpdate = (this.isSpeechOn == 0) ? false : true;
		}catch(e){
			//console.log("video is not ready");
		}
	},
	
	initMiddlewareCallbacks : function(context){
		console.log("callbacks for middleware registered");
		var voteInfo = {"vote":"", "origin":"physical"};
		//Register callbacks for speaker/coordinator
		this.virtual.onreceivecomment = function(username, comment) {
			context.entity.exec(EntityAction.Server, _MSG_COMMENTS, {"userName":username, "comment":comment, "origin":"physical"});};
		this.virtual.onreceivelikes = function(likes){
			voteInfo.vote = 1;
			context.entity.exec(EntityAction.Server, _MSG_VOTE, voteInfo);};	// count on 'like' has been updated by physical world
		this.virtual.onreceivedislikes = function(dislikes){
			voteInfo.vote = 0;
			context.entity.exec(EntityAction.Server, _MSG_VOTE, voteInfo);};	// count on 'dislike' has been updated by physical world
		//this.virtual.onreceivereports = function(reports){
		//	voteInfo.vote = -1;
		//	context.entity.exec(EntityAction.Server, _MSG_VOTE, voteInfo);};	// count on 'report' has been updated by physical world
		this.virtual.onreceivecurrentusers = function(users){};  		//TODO - using online and offline in virtual to handle this inf
				this.virtual.onstopspeech = function(){
			console.log("closed.....");
			context.entity.exec(EntityAction.Server, _MSG_SPEECH_END_REQUEST, {'signal':1, 'origin':'physical'});
		}	// stopped speech in physical world
	},
	
	// init new user with params which sent from the server
	initParams : function(initObj){
		console.log("current speech state: "+initObj.speechState);
		this.isSpeechOn = initObj.speechState; 					// init speech state
		this.userInfo.id = initObj.userId;						// user id issued by server
		this.userInfo.avatarName = "Avatar" + initObj.userId;   // user avatar entity name
		var actUserCnt = initObj.actUserCnt;					// users count who are possibly watching the speech
		
		if(initObj.coordinatorId){
			this.coordinatorInfo.id = initObj.coordinatorId;
			this.coordinatorInfo.name = initObj.coordinatorName;
			console.log(this.coordinatorInfo);
		}
		console.log(this.userInfo);
		console.log("active user count: "+ actUserCnt);
		
		// important!!
		// init callbacks of middleware to sync all the data
		if(this.isCoordinatorMe()){
			this.initMiddlewareCallbacks(this);
		}
		
		// register this avatar entity to the listeners
		try{
			this.avatarEntity = Tundra.scene.entityByName(this.userInfo.avatarName);
			this.avatarEntity.onEntityAction(this, this.onEntityAction);
			console.log(this.avatarEntity);
		}catch(e){
			console.log("Warning!!!, your avatar may not be able to trigger the speech");
		}
		// change the screen size according to the count of active users
		this.changeScreenSize(actUserCnt);		
		if(this.isSpeechOn == 0 | typeof this.isSpeechOn == "undefined"){
			// user init with waiting mode
			this.screenMesh.material.map = this.texture_waiting;
		// if there is a speech going right now
		}else if(this.isSpeechOn == 1){
			// init speaker info if exist
			this.speakerInfo = {"speakerInfo":[{"generalInfo":{"name" : initObj.speakerName, "id" : initObj.speakerId}}
			,{"entityInfo":{"entityName" : initObj.speakerEntityName, "entityId" : initObj.speakerEntityId}}]};
			// set video texture 
			this.screenMesh.material.map = this.videoTexture;
			// init current like/dislike state sent from server
			this.refreshVote(initObj.like, initObj.dislike);
			$("dashboard").show();
		}
	},
	sendToServer : function() {
        var asString = Tundra.renderer.renderer.domElement.toDataURL();
 
         if (isOpen) {
         	console.log("open"); 
            frame++;
            ws.send(str2ab(frame+asString));
         }
    },
 
    str2ab : function(str) {
        var buf = new ArrayBuffer(str.length);
        var bufView = new Uint8Array(buf);
        for (var i=0, strLen=str.length; i<strLen; i++) {
            bufView[i] = str.charCodeAt(i);
        }
        return buf;
    }
});


// UBI HOTSPOT ASSET, not relevant to this system
function haejongAsset(asset){

	var entity_soapHolder = Tundra.scene.createLocalEntity(["Name", "Mesh", "Placeable"]);
	var entity_hotspot = Tundra.scene.createLocalEntity(["Name", "Mesh", "Placeable"]);

	entity_soapHolder.name = "soapbox_foothold";
	entity_hotspot.name = "hotpot";

	entity_soapHolder.mesh.meshRef = "local://soapbox_foothold.mesh";
	entity_soapHolder.mesh.materialRefs = ["local://soapbox_foothold.material"];

	entity_hotspot.mesh.meshRef = "local://Cube.001.mesh";
	entity_hotspot.mesh.materialRefs = [
		"local://sides.material",
		"local://front.material",
		"local://back.material"];

	entity_soapHolder.placeable.setPosition(new THREE.Vector3(66.21,9.59,-44));
	entity_soapHolder.placeable.setScale(new THREE.Vector3(1, 1, 1));
	entity_soapHolder.placeable.setRotation(new THREE.Vector3(0, 52, 0));


	entity_hotspot.placeable.setPosition(new THREE.Vector3(70.2041016,7.68280506,-44.3602066));
	entity_hotspot.placeable.setScale(new THREE.Vector3(1, 1, 1));
	entity_hotspot.placeable.setRotation(new THREE.Vector3(0, 52, 0));
	console.log(entity_soapHolder);

}

// TODO: handling keyboard press when starting speech

// Start the application by instantiating it
var webRocketApplication = new WebRocketApplication();